{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./javascripts/ColorObject.js","webpack:///./javascripts/colorMathConstants.js","webpack:///./javascripts/colorMethods/cmykFromRGB.js","webpack:///./javascripts/colorMethods/hslFromRGB.js","webpack:///./javascripts/colorMethods/hsluvFromRGB.js","webpack:///./javascripts/colorMethods/hsvFromRGB.js","webpack:///./javascripts/colorMethods/hueFromRGB.js","webpack:///./javascripts/colorMethods/index.js","webpack:///./javascripts/colorMethods/pureFromHue.js","webpack:///./javascripts/colorMethods/rgbFromCMYK.js","webpack:///./javascripts/colorMethods/rgbFromHSL.js","webpack:///./javascripts/colorMethods/rgbFromHSLUV.js","webpack:///./javascripts/colorMethods/rgbFromHSV.js","webpack:///./javascripts/colorMethods/triFromRGB.js","webpack:///./javascripts/constants.js","webpack:///./javascripts/createSVG.js","webpack:///./javascripts/gradientGenerators/conicGradient.js","webpack:///./javascripts/gradientGenerators/linearGradient.js","webpack:///./javascripts/gradientGenerators/triangleGradient.js","webpack:///./javascripts/gradientGenerators/utils/getPattern.js","webpack:///./javascripts/gradientGenerators/xyGradient.js","webpack:///./javascripts/hueSlider.js","webpack:///./javascripts/index.js","webpack:///./javascripts/lightnessBlocks.js","webpack:///./javascripts/makeColorPalette.js","webpack:///./javascripts/sliderSet.js","webpack:///./javascripts/triangle.js","webpack:///./javascripts/utils/allEqualExcept.js","webpack:///./javascripts/utils/extrema.js","webpack:///./javascripts/utils/isEqual.js","webpack:///./javascripts/webgl/shaders/basicVertexShader.glsl","webpack:///./javascripts/webgl/shaders/conicGradient.glsl","webpack:///./javascripts/webgl/shaders/gradient1D.glsl","webpack:///./javascripts/webgl/shaders/triangleGradient.glsl","webpack:///./javascripts/webgl/shaders/xyGradient.glsl","webpack:///./javascripts/webgl/utils.js","webpack:///./javascripts/xySlider.js","webpack:///./node_modules/hsluv/hsluv.js"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAA6C;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,0CAA0C;AAC1C,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,K;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,2DAAS;;AAErB;AACA;AACA;AACA;AACA,gBAAgB,2DAAS;AACzB;AACA;AACA,SAAS;;AAET;AACA;AACA,8CAA8C,qBAAqB;AACnE;AACA;AACA,gDAAgD,qBAAqB;AACrE;AACA;AACA,8CAA8C,qBAAqB;AACnE;AACA;;AAEA;AACA;AACA;;AAEe,0EAAW,E;;;;;;;;;;;;ACvH1B;AAAA;AAAA;AAAA;AAAO;AACP;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7BA;AAAA;AAAsC;;AAEvB;AACf,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA,2BAA2B,8DAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACdA;AAAA;AAAA;AAAA;AAAuC;AACD;;AAEvB;AACf,WAAW,WAAW,GAAG,8DAAO;AAChC;AACA,gBAAgB,2DAAU;AAC1B;AACA;AACA,YAAY;AACZ,C;;;;;;;;;;;;ACVA;AAAA;AAAA;AAAA;AAAiC;;AAElB;AACf,kBAAkB,wDAAU;AAC5B;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACTA;AAAA;AAAA;AAAA;AAAsC;AACC;;AAExB;AACf,WAAW,SAAS,GAAG,8DAAO;AAC9B;AACA;AACA,iBAAiB,2DAAU;AAC3B,YAAY;AACZ,C;;;;;;;;;;;;ACTA;AAAA;AAAA;AAAsC;AACvB;AACf,QAAQ,WAAW,GAAG,8DAAO;AAC7B;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,EAAE;AACF;AACA;;AAEA;AACA,C;;;;;;;;;;;;ACdA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAsC;AACI;AACJ;AACE;;AAEF;AACI;AACJ;AACE;;AAEzB;AACf;AACA,aAAa,mDAAU;AACvB,eAAe,qDAAY;AAC3B,aAAa,mDAAU;AACvB,cAAc,oDAAW;AACzB;AACA,KAAK;AACL;AACA,aAAa,mDAAU;AACvB,eAAe,qDAAY;AAC3B,aAAa,mDAAU;AACvB,cAAc,oDAAW;AACzB;AACA;AACA,C;;;;;;;;;;;;ACzBA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEe;AACf;AACA,YAAY;AACZ,C;;;;;;;;;;;;ACrBA;AAAe;AACf,WAAW,6BAA6B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;;;;ACVe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC7CA;AAAA;AAAA;AAAA;AAA6C;;;AAG7C,aAAa,gDAAU;AACvB,aAAa,gDAAU;;AAER;AACf,kBAAkB,wDAAU;AAC5B;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACbA;AAAA;AAAe;AACf;AACA;AACA;AACA,qE;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC5BA;AAAA;AAAA;AAAA;AAAsC;AACA;;AAEA;AACvB;AACf,UAAU,WAAW,GAAG,8DAAO;AAC/B;AACA;AACA;AACA,WAAW;AACX,C;;;;;;;;;;;;ACVA;AAAA;;AAEe;AACf;AACA;AACA;AACA;AACA,4BAA4B,mBAAmB;AAC/C,wBAAwB;AACxB,KAAK;AACL;AACA;AACA,C;;;;;;;;;;;;ACZA;AAAA;AAAe;AACf;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,iB;;;;;;;;;;;;ACRA;AAAA;AAAA;AAAA;AAAiE;AACrB;;AAE7B;AACf;AACA;AACA,CAAC;AACD,WAAW,iEAAU;AACrB;AACA;AACA,gBAAgB,yEAAc;AAC9B,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,KAAK;AACL,C;;;;;;;;;;;;;;;;;;;AC5BuE;AACT;AACT;AACT;;;AAG7B;AACf;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,WAAW,iEAAU;AACrB;AACA;AACA,gBAAgB,sEAAc;AAC9B;AACA;AACA;AACA,uBAAuB,+DAAW;AAClC,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,uBAAuB,6DAAS;AAChC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,wBAAwB,qEAAc;AACtC;AACA;AACA;AACA;AACA,iCAAiC,6DAAS;AAC1C,6CAA6C,4DAAQ;AACrD,qBAAqB;AACrB;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;;;;;;;;;;;;AClDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAsD;AACc;AACxB;AACL;;AAExB;AACf;AACA;AACA;AACA;AACA,CAAC;AACD,SAAS,iEAAU;AACnB;AACA;AACA,YAAY,4EAAc;AAC1B;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,uBAAuB,yEAAW;AAClC,2BAA2B,yEAAW;AACtC,cAAc,8DAAO;AACrB;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL,GAAG;AACH;;;;;;;;;;;;;;;;;;;;ACpC4E;AAClC;AACF;AAC8B;;AAEvD;AACf;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,oBAAoB,0DAAS;AAC7B;AACA;AACA;AACA;AACA,KAAK;AACL,6BAA6B,yBAAyB;AACtD,kBAAkB,0DAAS;AAC3B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,yBAAyB,iEAAY,uBAAuB,6EAAY;AACxE,2BAA2B,iEAAY;;AAEvC,oBAAoB,kEAAa;AACjC;;AAEA;AACA;;AAEA;AACA,eAAe,YAAY;AAC3B;AACA;AACA,KAAK;;;AAGL,IAAI,oDAAS;AACb;AACA,mBAAmB,aAAa;AAChC;AACA;AACA;AACA;AACA;AACA,a;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA,QAA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B;AACrB;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA,kBAAkB,0DAAS;AAC3B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA,IAAI,oDAAS;AACb;AACA;;AAEA,qBAAqB,KAAK;AAC1B;AACA;AACA;AACA,2BAA2B,cAAc,GAAG,gBAAgB,GAAG,eAAe;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,2DAAS;AACnC;AACA,sBAAsB;AACtB;AACA,qBAAqB,4BAA4B;AACjD;AACA;AACA;AACA,uBAAuB,UAAU,GAAG,YAAY,GAAG,WAAW;AAC9D;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,C;;;;;;;;;;;;AChHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAsC;AACE;AACW;;;;;;AAMnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB,wEAAU;AAC/B,sBAAsB,yCAAW;AACjC,wBAAwB,yCAAW;AACnC,uBAAuB,yCAAW;AAClC,KAAK;AACL;AACA;;AAEA;AACA;AACA,gBAAgB,yCAAW;AAC3B;;AAEA,mBAAmB,wEAAU;;AAE7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;;;AAKA;AACA,oB;AACA,gB;AACA,mB;AACA,yB;AACA;AACA;;AAEA;AACA;AACA,0CAA0C,oDAAS;AACnD;AACA,sCAAsC,aAAa;AACnD;AACA,uBAAuB,4BAA4B;AACnD,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA,KAAK;AACL;AACA,eAAe,SAAS,OAAO,mBAAmB,EAAE,EAAE,GAAG,oDAAS;AAClE;AACA;AACA,0CAA0C,gBAAgB;AAC1D,wGAAwG,WAAW,WAAW,gBAAgB;AAC9I,wGAAwG,WAAW,WAAW,kBAAkB;AAChJ,wGAAwG,WAAW,WAAW,iBAAiB;AAC/I,0CAA0C,gBAAgB;AAC1D;AACA;AACA;AACA;;;;AAIe,2BAA2B,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,IAAI,oDAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA,CAAC,gCAAgC;AACjC,8BAA8B,a;;;;;;;;;;;;;;;;;;;;;;;AC1I9B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAoC;AACE;AACc;AACT;;;;AAI3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;;;AAGA,sBAAsB,0DAAS;AAC/B;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL,6CAA6C,GAAG,GAAG,GAAG;;AAEtD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,mC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,uBAAuB,aAAa;AACpC;AACA;AACA,oBAAoB,gHAAgH;AACpI;AACA,SAAS;;;AAGT;AACA;AACA;AACA,YAAY;;AAEZ;AACA;AACA,uBAAuB,aAAa;AACpC;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA,QAAQ,oDAAS;AACjB;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,YAAY,oDAAS;AACrB;AACA,iBAAiB;AACjB;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET,yBAAyB,0DAAS;AAClC;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET,sBAAsB,0DAAS;AAC/B;AACA;AACA,SAAS;;AAET,sBAAsB,0DAAS;AAC/B;AACA;AACA,SAAS;;AAET,sBAAsB,0DAAS;AAC/B;AACA;A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,GAAG,WAAW;AAC5C,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;;AAGH,eAAe,0DAAS;AACxB,4BAA4B,YAAY,GAAG,YAAY;AACvD,GAAG;;AAEH,gCAAgC,kFAAc;AAC9C;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH,cAAc,0DAAS;AACvB;AACA;AACA;AACA;AACA,GAAG;;AAEH,YAAY,0DAAS;AACrB;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,IAAI,oDAAS;AACb;AACA,OAAO,4BAA4B;AACnC;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH,YAAY,0DAAS;AACrB;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,IAAI,oDAAS;AACb;AACA,OAAO,4BAA4B;AACnC;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;;AAEA,oBAAoB,0DAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,uBAAuB,oDAAS;AAChC;AACA;AACA,MAAM,oDAAS;AACf;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK,GAAG,aAAa;AACrB,GAAG;;AAEH,EAAE,oDAAS;AACX;AACA;AACA,GAAG;;AAEH,sBAAsB,0DAAS;AAC/B;AACA;AACA,kBAAkB,yBAAyB;AAC3C;AACA,GAAG;;AAEH;AACA;;AAEA,EAAE,oDAAS;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oDAAS;AAC5B,mBAAmB,oDAAS;;AAE5B;AACA;;AAEA;AACA;;AAEA,MAAM,oDAAS;AACf;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,GAAG,aAAa;AACrB,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,IAAI,oDAAS;AACb;AACA,OAAO,4BAA4B;AACnC;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;ACpRA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kDAAkD;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./javascripts/index.js\");\n","import converter from './colorMethods/index';\n\nfunction deepDup(obj){\n    const newObj = {};\n    Object.keys(obj).forEach(k => {\n        newObj[k] = (typeof obj[k] === 'object') ?\n        deepDup(obj[k]) :\n        obj[k]\n    })\n    return newObj;\n}\n\nfunction isEqualPartial(partial,obj){\n    const keys = Object.keys(partial || {});\n    for (let i=0; i<keys.length; i++){\n        if (partial[keys[i]] !== obj[keys[i]]) return false;\n    }\n    return true;\n}\n\nfunction patchError(obj, prev){\n    const keys = Object.keys(obj);\n    for (let i=0; i<keys.length; i++){\n        if (\n            obj[keys[i]] === Infinity ||\n            obj[keys[i]] === -Infinity ||\n            Number.isNaN(obj[keys[i]])\n        ) obj[keys[i]] = prev[keys[i]]\n    }\n    return obj;\n}\n\nfunction patchHSLUV(obj, prev){\n    //todo: add checks for maxes, not just mins\n    if (obj.saturation < 1e-8){\n        obj.hue = prev.hue;\n    }\n    if (obj.lightness < 1e-8 || Math.abs(obj.lightness - 100) < 1e-8){\n        obj.hue = prev.hue;\n        obj.saturation = prev.saturation;\n    } \n    return obj;\n}\n\nexport class Color {\n    constructor(){\n        this.color = {\n            rgb: {\n                red: -1,\n                green: -1,\n                blue: -1,\n            },\n\n            hsv: {\n                hue: -1,\n                saturation: -1,\n                value: -1,\n            },\n\n            hsl:{\n                hue: -1,\n                saturation: -1,\n                lightness: -1,\n            },\n\n            hsluv:{\n                hue: -1,\n                saturation: -1,\n                lightness: -1\n            },\n\n            cmyk:{\n                cyan: -1,\n                magenta: -1,\n                yellow: -1,\n                black: -1\n            }\n        }\n        this.subscriptions = [];\n    }\n\t\n\tsubscribe(callback){\n\t\tthis.subscriptions.push(callback);\n\t}\n    \n    set(colorSpace, partial){\n        if (isEqualPartial(partial,this.color[colorSpace])) return;\n\n        const prev = deepDup(this.color);\n        Object.assign(this.color[colorSpace], partial);\n        this.color.rgb = colorSpace === 'rgb' ? \n            this.color.rgb : \n            converter.getRGB[colorSpace](this.color[colorSpace]);\n\n        const spaces = Object.keys(this.color);\n        spaces.forEach(space => {\n            if (space === 'rgb' || space === colorSpace) return;\n            this.color[space] = patchError(\n                converter.fromRGB[space](this.color.rgb),\n                this.color[space]\n            )\n        })\n\n        if (partial.hue) {\n            if (colorSpace !== 'hsl'){\n                Object.assign(this.color.hsl,{hue: partial.hue%360});\n            }\n            if (colorSpace !== 'hsluv'){\n                Object.assign(this.color.hsluv,{hue: partial.hue%360});\n            }\n            if (colorSpace !== 'hsv'){\n                Object.assign(this.color.hsv,{hue: partial.hue%360});\n            }\n        }\n\n        this.subscriptions.forEach(subscription => subscription(this.color, prev));\n    }\n}\n\nexport default new Color();","export const COLOR_SPACE = {\n    'hsl': 0,\n    'hsv': 1,\n}\n\nexport const COLOR_ORD = {\n    hsl: {\n        hue: 0,\n        saturation: 1,\n        lightness: 2,\n    },\n    hsv: {\n        hue: 0,\n        saturation: 1,\n        value: 2,\n    }\n}\n\nexport const CHAN_MAX = {\n    hsl: {\n        hue: 360,\n        saturation: 100,\n        lightness: 100,\n    },\n    hsv: {\n        hue: 360,\n        saturation: 100,\n        value: 100,\n    }\n}\n","import extrema from '../utils/extrema'\n\nexport default function(color){\n    const {red, green, blue} = color;\n    const r = red/255;\n    const g = green/255;\n    const b = blue/255;\n    const k = (255 - color[extrema(color).max])/255;\n    return {\n        cyan: (1-r-k)/(1-k)*100,\n        magenta: (1-g-k)/(1-k)*100,\n        yellow: (1-b-k)/(1-k)*100,\n        black: k*100\n    }\n}","import extrema from '../utils/extrema';\nimport hueFromRGB from './hueFromRGB';\n\nexport default function hslFromRGB(rgb){\n    const { max, min } = extrema(rgb);\n    const lightness = (rgb[max] + rgb[min])/2 /255;\n    const hue = hueFromRGB(rgb);\n    let saturation;\n    saturation = (rgb[max] - rgb[min])/255 /(1 - Math.abs(2*lightness - 1));\n    return { saturation: saturation*100, lightness: lightness*100, hue };\n}","import {rgbToHsluv} from 'hsluv';\n\nexport default function hsluvFromRGB(rgb){\n    const color = rgbToHsluv([rgb.red/255, rgb.green/255, rgb.blue/255]);\n    return {\n        hue: color[0],\n        saturation: color[1],\n        lightness: color[2]\n    }\n}","import hueFromRGB from './hueFromRGB';\nimport extrema from '../utils/extrema';\n\nexport default function hsvFromRGB(rgb){\n    const {max, min} = extrema(rgb);\n    const saturation = (1-rgb[min]/rgb[max]) * 100;\n    const value = rgb[max]/255 * 100;\n    const hue  = hueFromRGB(rgb);\n    return {hue, saturation, value}\n}","import extrema from '../utils/extrema'\nexport default function hueFromRGB(rgb){\n\tconst { max, min } = extrema(rgb);\n\tconst c = rgb[max] - rgb[min];\n\tlet hue = null\n\tif (max === 'red'){\n\t\thue = ((rgb.green - rgb.blue)/c + 6)%6\n\t} else if (max === 'green') {\n\t\thue = (rgb.blue - rgb.red)/c + 2;\n\t} else if (max === 'blue'){\n\t\thue = (rgb.red - rgb.green)/c + 4;\n\t}\n\t\n\treturn hue/6 * 360;\n}","import hslFromRGB from './hslFromRGB';\nimport hsluvFromRGB from './hsluvFromRGB';\nimport hsvFromRGB from './hsvFromRGB';\nimport cmykFromRGB from './cmykFromRGB';\n\nimport rgbFromHSL from './rgbFromHSL';\nimport rgbFromHSLUV from './rgbFromHSLUV';\nimport rgbFromHSV from './rgbFromHSV';\nimport rgbFromCMYK from './rgbFromCMYK';\n\nexport default {\n    getRGB: {\n        hsl: rgbFromHSL,\n        hsluv: rgbFromHSLUV,\n        hsv: rgbFromHSV,\n        cmyk: rgbFromCMYK,\n        rgb: v => v,\n    },\n    fromRGB: {\n        hsl: hslFromRGB,\n        hsluv: hsluvFromRGB,\n        hsv: hsvFromRGB,\n        cmyk: cmykFromRGB,\n        rgb: v => v\n    }\n}","function color(sixth){\n\tswitch (Math.floor(sixth)){\n\t\tcase 0:\n\t\t\treturn [255, 255*(sixth%1), 0, 255];\n\t\tcase 1:\n\t\t\treturn [255 * (1-sixth%1), 255, 0, 255];\n\t\tcase 2:\n\t\t\treturn [0, 255, 255 * (sixth%1), 255];\n\t\tcase 3:\n\t\t\treturn [0, 255 * (1-sixth%1), 255, 255];\n\t\tcase 4:\n\t\t\treturn [255 * (sixth%1), 0, 255, 255];\n\t\tcase 5:\n\t\t\treturn [255, 0, 255 * (1-sixth%1), 255];\n\t}\nreturn [0,0,0,0]\n}\n\nexport default function pureFromHue(hue){\n    const [red, green, blue] = color(hue/60);\n    return { red, green, blue }\n}","export default function(color){\n    const {cyan, magenta, yellow, black} = color;\n    const c = cyan/100;\n    const m = magenta/100;\n    const y = yellow/100;\n    const k = black/100;\n    return {\n        red: (1-c)*(1-k)*255,\n        green: (1-m)*(1-k)*255,\n        blue: (1-y)*(1-k)*255\n    }\n}","\nexport default function rgbFromHSL(hsl){\n    const C = (1 - Math.abs(2*hsl.lightness/100 - 1))*hsl.saturation/100;\n    const H = hsl.hue/60;\n    const X = C * (1 - Math.abs(H%2-1));\n    const m = hsl.lightness/100 - C/2;\n    switch (Math.floor(H)){\n        case 6:\n        case 0:\n            return {\n                red: 255*(C + m),\n                green: 255*(X + m),\n                blue: 255*m\n            }\n        case 1:\n            return {\n                red: 255*(X + m),\n                green: 255*(C + m),\n                blue: 255*m\n            }\n        case 2:\n            return {\n                red: 255*m,\n                green: 255*(C + m),\n                blue: 255*(X + m)\n            }\n        case 3:\n            return {\n                red: 255*m,\n                green: 255*(X + m),\n                blue: 255*(C + m),\n            }\n        case 4:\n            return {\n                red: 255*(X + m),\n                green: 255*m,\n                blue: 255*(C + m),\n            }\n        case 5:\n            return {\n                red: 255*(C + m),\n                green: 255*m,\n                blue: 255*(X + m),\n            }\n    }\n}","import {hsluvToRgb, rgbToHsluv} from 'hsluv';\n\n\nwindow.h2r = hsluvToRgb;\nwindow.r2h = rgbToHsluv;\n\nexport default function hsluvFromRGB(hsluv){\n    const color = hsluvToRgb([hsluv.hue, hsluv.saturation, hsluv.lightness]);\n    return {\n        red: color[0]*255,\n        green: color[1]*255,\n        blue: color[2]*255\n    }\n}","export default function rgbFromHSV(hsv){\n\tlet max, min, mid;\n\tif ((hsv.hue + 60)%360 <= 120){\n\t\tmax = 'red';\n\t\t[min, mid] = hsv.hue <= 60 ? ['blue', 'green'] : ['green', 'blue'];\t\n\t} else if (hsv.hue <= 180) {\n\t\tmax = 'green';\n\t\t[min, mid] = hsv.hue <= 120 ? ['blue', 'red'] : ['red', 'blue'] \n\t} else {\n\t\tmax = 'blue';\n\t\t[min, mid] = hsv.hue <= 240 ? ['red', 'green'] : ['green', 'red']\n\t}\n\t\n\tlet progress = (hsv.hue%60) / 60;\n\tif (Math.floor(hsv.hue/60)%2 === 1){\n\t\tprogress = 1 - progress\n\t};\n\t\n\t\n\tconst maxval = 255/100 * hsv.value;\n\tconst minval = (100 - hsv.saturation) * maxval / 100;\n\tconst midval = minval + (maxval - minval)*progress;\n\t\n\treturn {\n\t\t[max]: maxval,\n\t\t[min]: minval,\n\t\t[mid]: midval,\n\t}\n}","import rgbFromHSV from './rgbFromHSV';\nimport hsvFromRGB from './hsvFromRGB';\n\nimport extrema from '../utils/extrema'\nexport default function(rgb){\n   const { max, min } = extrema(rgb);\n   const white = rgb[min]/255;\n   const color = (rgb[max] - 255*white)/255;\n   const black = 1 - white - color;\n   return {white, black, color};\n}","let hueSlider;\n\nexport default {\n    hueSlider: {\n        svgMargin: 20,\n        radius: 140,\n        trackThickness: 8,\n        set: function(that){ hueSlider = that },\n        get: function(){ return hueSlider }\n    },\n    triangleSlider: {\n    }\n}","export default function createSVG(type,props){\n    const el = document.createElementNS('http://www.w3.org/2000/svg', type);\n    el.id = createSVG.id++;\n    Object.keys(props).forEach(key => {\n        el.setAttribute(key,props[key]);\n    })\n    return el;\n}\ncreateSVG.id = 0;","import fragmentScript from '../webgl/shaders/conicGradient.glsl';\nimport getPattern from './utils/getPattern';\n\nexport default function conicGradient({\n    height,\n    width,\n}){\n    return getPattern({\n        height,\n        width,\n        script: fragmentScript,\n        staticUniforms: {},\n        dynamicUniforms: {\n            u_saturation: {\n                type: 'uniform1f',\n                setter: ((COLOR, PREV) => {\n                    if (COLOR.hsl.saturation === PREV.hsl.saturation) return false;\n                    return COLOR.hsl.saturation/100;\n                }),\n            },\n            u_lightness: {\n                type: 'uniform1f',\n                setter: ((COLOR, PREV) => {\n                    if (COLOR.hsl.lightness === PREV.hsl.lightness) return false;\n                    return COLOR.hsl.lightness/100;\n                }),\n            }\n        }\n    })\n}","\nimport {COLOR_SPACE, COLOR_ORD, CHAN_MAX} from '../colorMathConstants';\nimport fragmentScript from '../webgl/shaders/gradient1D.glsl';\nimport allEqualExcept from '../utils/allEqualExcept';\nimport getPattern from './utils/getPattern';\n\n\nexport default function linearGradient({\n    colorSpace, \n    channel, \n    padding, \n    height, \n    width,\n}){\n    return getPattern({\n        height,\n        width,\n        script: fragmentScript,\n        staticUniforms: {\n            u_colorspace: {\n                type: 'uniform1i',\n                value: COLOR_SPACE[colorSpace], \n            },\n            u_padding: {\n                type: 'uniform1f',\n                value: padding,\n            },\n            u_chan: {\n                type: 'uniform1i',\n                value: COLOR_ORD[colorSpace][channel],\n            }\n        },\n        dynamicUniforms: {\n            u_color: {\n                type: 'uniform3f',\n                setter: (COLOR, PREV) => {\n                    // don't need to update if every other channel in this colorspace is the same.\n                    if (allEqualExcept(channel, COLOR[colorSpace], PREV[colorSpace])) {\n                        return false;\n                    }\n                    const vecColor = [];\n                    Object.keys(COLOR[colorSpace]).forEach(k => {\n                        vecColor[COLOR_ORD[colorSpace][k]] = \n                        COLOR[colorSpace][k]/CHAN_MAX[colorSpace][k];\n                    })\n                    return vecColor;\n                }\n            }\n        },\n    })   \n}\n","import pureFromHue from '../colorMethods/pureFromHue';\nimport fragmentScript from '../webgl/shaders/triangleGradient.glsl';\nimport getPattern from './utils/getPattern';\nimport isEqual from '../utils/isEqual';\n\nexport default function triangleGradient({\n  height,\n  width,\n  side,\n  margin,\n}) {\n  return getPattern({\n    height,\n    width,\n    script: fragmentScript,\n    staticUniforms: {\n      u_side: {\n        type: 'uniform1f',\n        value: side,\n      },\n      u_margin: {\n        type: 'uniform1f',\n        value: margin,\n      },\n    },\n    dynamicUniforms: {\n      u_color: {\n        type: 'uniform3f',\n        setter: (COLOR, PREV) => {\n          const pure = pureFromHue(COLOR.hsl.hue % 360);\n          const prevPure = pureFromHue(PREV.hsl.hue % 360);\n          if (isEqual(pure, prevPure)) return false;\n          return ['red', 'green', 'blue'].map((k) => pure[k] / 255);\n        },\n      },\n    },\n  });\n}\n","\nimport {createShader, createProgram, drawVertices} from '../../webgl/utils';\nimport mainColor from '../../ColorObject';\nimport createSVG from '../../createSVG';\nimport vertexScript from '../../webgl/shaders/basicVertexShader.glsl';\n\nexport default function getPattern({\n    height, \n    width, \n    staticUniforms, \n    dynamicUniforms, \n    script,\n}){\n    const pattern = createSVG('pattern',{\n        height: 1,\n        width: 1,\n        patternUnits: 'objectBoundingBox',\n        patternContentUnits: 'objectBoundingBox',\n    })\n    pattern.id = `GRADIENT_${getPattern.callCounter++}`\n    const image = createSVG('image',{\n       height: 1,\n       width: 1,\n       x:0,\n       y:0,\n       preserveAspectRatio: 'none'\n    })\n    pattern.appendChild(image);\n\n    const canvas = document.createElement('canvas');\n    canvas.height = height;\n    canvas.width = width;\n\n    const gl = canvas.getContext('webgl');\n    if (!gl) throw new Error(\"Could not find WebGL context\");\n\n    const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexScript);\n    const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, script);\n\n    const program = createProgram(gl, vertexShader, fragmentShader);\n    gl.useProgram(program);\n\n    const u_res = gl.getUniformLocation(program, \"u_res\");\n    gl.uniform2f(u_res, gl.canvas.width, gl.canvas.height);\n\n    Object.keys(staticUniforms).forEach((name) => {\n        const {type, value} = staticUniforms[name];\n        const loc = gl.getUniformLocation(program, name);\n        gl[type](loc, ...(Array.isArray(value) ? value : [value]));\n    })\n\n\n    mainColor.subscribe((COLOR, PREV) => {\n        const newUniforms = Object.keys(dynamicUniforms).map((name) => {\n            const {setter, type} = dynamicUniforms[name];\n            const loc = gl.getUniformLocation(program, name);\n            return {\n                value: setter(COLOR, PREV),\n                type,\n                loc,\n            } \n        });\n        if (!newUniforms.every(u => u.value === false)) {\n            newUniforms.forEach(u => {\n                // return false when you don't want to update.\n                if (u.value === false) return;\n                gl[u.type](u.loc, ...(Array.isArray(u.value) ? u.value : [u.value]));\n            })\n        }\n\n        drawVertices(gl, program, \"a_position\");\n        image.setAttribute('href', canvas.toDataURL());\n    })\n\n    return pattern;\n}\ngetPattern.callCounter = 0;","import fragmentScript from '../webgl/shaders/xyGradient.glsl';\nimport { COLOR_ORD, CHAN_MAX, COLOR_SPACE } from '../colorMathConstants';\nimport getPattern from './utils/getPattern';\n\nexport default function xyGradient({\n  height,\n  width,\n  padding,\n  colorSpace,\n  xChannel,\n  yChannel,\n  zChannel,\n}) {\n  return getPattern({\n    height,\n    width,\n    script: fragmentScript,\n    staticUniforms: {\n      u_colorspace: {\n        type: 'uniform1i',\n        value: COLOR_SPACE[colorSpace],\n      },\n      u_ord: {\n        type: 'uniform3i',\n        value: [xChannel, yChannel, zChannel]\n          .map((c) => COLOR_ORD[colorSpace][c]),\n      },\n      u_padding: {\n        type: 'uniform1f',\n        value: padding,\n      },\n    },\n    dynamicUniforms: {\n      u_z: {\n        type: 'uniform1f',\n        setter: (COLOR, PREV) => {\n          if (COLOR[colorSpace][zChannel] === PREV[colorSpace][zChannel]) return false;\n          const color = COLOR[colorSpace][zChannel] / CHAN_MAX[colorSpace][zChannel];\n          return color;\n        },\n      },\n    },\n  });\n}\n","import mainColor from './ColorObject';\nimport conicGradient from './gradientGenerators/conicGradient';\nimport createSVG from './createSVG';\nimport c from './constants';\n\nlet RADIUS = 100;\n\nexport default function hueSlider(target) {\n  if (!target) target = document.body;\n\n  const thickness = c.hueSlider.trackThickness;\n  const marg = c.hueSlider.svgMargin;\n\n  const svg = createSVG('svg', {\n    viewBox: `0 0 ${RADIUS * 2 + marg} ${RADIUS * 2 + marg}`,\n    height: RADIUS * 2 + marg,\n  });\n\n  c.hueSlider.set(svg);\n\n  const defs = createSVG('defs', {});\n  const mask = createSVG('mask', {});\n\n  const maskBG = createSVG('rect', {\n    fill: 'white',\n  });\n\n  const maskCircle = createSVG('circle', {\n    fill: 'black',\n  });\n\n  const pattern = conicGradient({\n    height: 400,\n    width: 400,\n  });\n\n  mask.appendChild(maskBG);\n  mask.appendChild(maskCircle);\n  defs.appendChild(mask);\n  defs.appendChild(pattern);\n\n  const gBody = createSVG('g', { transform: `translate( ${marg / 2} ${marg / 2})` });\n\n  const gHue = createSVG('g', {});\n\n  const hueTrack = createSVG('circle', {\n    fill: `url(#${pattern.id})`,\n    mask: `url(#${mask.id})`,\n  });\n\n  const gPip = createSVG('g', {\n    filter: 'url(#shadow)',\n  });\n  const huePipH = 12;\n  const huePipW = 10;\n  const pipRect = createSVG('rect', {\n    width: huePipW,\n    height: huePipH,\n    rx: 2,\n    fill: 'transparent',\n    'stroke-width': 2,\n    stroke: 'white',\n    'vector-effect': 'non-scaling-stroke',\n  });\n  gBody.appendChild(gHue);\n  gHue.appendChild(hueTrack);\n\n  gBody.appendChild(gPip);\n  gPip.appendChild(pipRect);\n\n  target.appendChild(svg);\n  svg.appendChild(defs);\n  svg.appendChild(gBody);\n\n  function resize() {\n    const { height } = target.getBoundingClientRect();\n    RADIUS = (height - marg) / 2;\n\n    svg.setAttribute('viewBox', `0 0 ${height} ${height}`);\n    svg.setAttribute('height', height);\n    maskCircle.setAttribute('r', RADIUS - thickness);\n    maskCircle.setAttribute('cx', RADIUS);\n    maskCircle.setAttribute('cy', RADIUS);\n    maskBG.setAttribute('height', RADIUS * 2);\n    maskBG.setAttribute('width', RADIUS * 2);\n    hueTrack.setAttribute('r', RADIUS);\n    hueTrack.setAttribute('cx', RADIUS);\n    hueTrack.setAttribute('cy', RADIUS);\n    gPip.setAttribute('transform', `translate(${RADIUS} ${RADIUS})`);\n    setPipFromColor(mainColor.color);\n  }\n  resize();\n  window.addEventListener('resize', resize);\n\n  function setPipFromColor(COLOR, PREV) {\n    if (PREV && COLOR.hsv.hue === PREV.hsv.hue) return;\n    pipRect.setAttribute('transform', `rotate(${COLOR.hsv.hue - 90})translate(${-huePipW / 2 + RADIUS - thickness / 2} ${-huePipH / 2})`);\n  }\n\n  mainColor.subscribe(setPipFromColor);\n\n  pipRect.addEventListener('mousedown', (e) => {\n    let [x, y] = [e.clientX, e.clientY];\n    function move(e) {\n      const delx = e.clientX - x; // note that this needs scaling if svg space is diff from user space\n      const dely = e.clientY - y;\n\n      const xnew = Math.cos((mainColor.color.hsv.hue - 90) / 180 * Math.PI) * (RADIUS - thickness / 2) + delx;\n      const ynew = Math.sin((mainColor.color.hsv.hue - 90) / 180 * Math.PI) * (RADIUS - thickness / 2) + dely;\n\n      let angle = Math.atan(ynew / xnew);\n      if (xnew < 0) angle = Math.PI + angle;\n\n      mainColor.set('hsv', { hue: angle / Math.PI * 180 + 90 });\n\n      x = e.clientX;\n      y = e.clientY;\n    }\n\n    document.addEventListener('mousemove', move);\n    document.addEventListener('mouseup', () => {\n      document.removeEventListener('mousemove', move);\n    }, { once: true });\n  });\n}\n","import mainColor from './ColorObject';\nimport makeHueSlider from './hueSlider';\nimport makeTriangle from './triangle';\n\nimport makeBlockWithSlider from './xySlider';\nimport makelightnessBlocks from './lightnessBlocks';\nimport buildChannels from './sliderSet';\nimport makeColorPalette from './makeColorPalette';\n\ndocument.addEventListener('DOMContentLoaded', () => {\n  setup();\n});\n\nfunction setup() {\n  // makeBlockWithSlider({\n  //     xChannel: 'hue',\n  //     yChannel: 'saturation',\n  //     zChannel: 'lightness',\n  //     colorSpace: 'hsl',\n  //     height: 150,\n  //     width: 350,\n  //     target: document.getElementById('block-sliders')\n  // });\n\n  // makeBlockWithSlider({\n  //     xChannel: 'saturation',\n  //     yChannel: 'value',\n  //     zChannel: 'hue',\n  //     colorSpace: 'hsv',\n  //     height: 150,\n  //     width: 150,\n  //     target: document.getElementById('block-sliders')\n  // });\n\n  makeHueSlider(document.getElementById('main'));\n  makeTriangle(document.getElementById('main'));\n\n  // buildChannels([\n  //     {type: 'rgb', channel: 'red'},\n  //     {type: 'rgb', channel: 'green'},\n  //     {type: 'rgb', channel: 'blue'},\n  // ],{\n  //     recipient: document.getElementById('rgb-cmyk')\n  // });\n\n  // buildChannels([\n  //     {type: 'cmyk', channel: 'cyan'},\n  //     {type: 'cmyk', channel: 'magenta'},\n  //     {type: 'cmyk', channel: 'yellow'},\n  //     {type: 'cmyk', channel: 'black'},\n  // ], {\n  //     recipient: document.getElementById('rgb-cmyk')\n  // });\n\n  // makelightnessBlocks('hsl', {name: 'lightness', max: 100}, document.getElementById('lightness-blocks'));\n  // makelightnessBlocks('hsl', {name: 'saturation', max: 100}, document.getElementById('lightness-blocks'));\n\n  // makeColorPalette({ target: document.getElementById('color-palette') });\n\n  mainColor.set('rgb', { red: 50, green: 100, blue: 200 });\n}\n","import mainColor from './ColorObject';\nimport createSVG from './createSVG';\nimport converter from './colorMethods/index';\n\n\nexport default function (colorSpace, channel, target){\n    const W = 510;\n    const N = 16;\n    const m = 1;\n    const w = (W-(m*(N-1)))/N;\n    const wmarg = 10;\n    const hmarg = 10;\n\n    const dir = \"v\";\n\n    if (!target) target = document.body;\n\n\n    const [ width, height ] = dir === 'v' ? [w + hmarg*2, W + wmarg*2] : [W + hmarg*2, w + wmarg*2]\n    \n\n    const svg = createSVG('svg',{\n        viewBox: `0 0 ${width} ${height}`\n    })\n\n    svg.style.height = '100%';\n    svg.style.width = 'auto';\n\n    const body = createSVG('g',{\n        transform: `translate(${dir === \"v\" ? hmarg : wmarg} ${dir === \"v\" ? wmarg : hmarg})`\n    });\n    svg.appendChild(body);\n\n\n    const blocks = []\n    for (let i=0; i<N; i++){\n        const block = createSVG('rect',{\n            height: w,\n            width: w,\n            [dir === 'v' ? 'y' : 'x']: i * (w + m),\n        })\n        block.addEventListener('click',()=>{\n            mainColor.set(colorSpace,\n                Object.assign(\n                    {},\n                    mainColor.color[colorSpace],\n                    {[channel.name]: i*[channel.max]/(N-1)}\n                )\n            )\n        })\n        body.appendChild(block);\n        blocks.push(block);\n    }\n\n    const wDel = 0;\n    const frame = createSVG('rect',{\n        height: w + wDel,\n        width: w + wDel,\n\n        fill: 'transparent',\n        stroke: 'white',\n        'stroke-width': 2,\n        filter: 'url(#shadow)',\n        rx: 2,\n        ry: 2\n    });\n    body.appendChild(frame);\n\n    mainColor.subscribe((COLOR, PREV) => {\n        const inc = (channel.max/(N-1));\n        const replacementIndex = Math.round(COLOR[colorSpace][channel.name]/inc);\n\n        for (let i=0; i<N; i++){\n            if (i === replacementIndex){\n                blocks[i].setAttribute(\n                    'fill',\n                    `rgb(${COLOR.rgb.red},${COLOR.rgb.green},${COLOR.rgb.blue})`,\n                );\n                frame.setAttribute(dir === 'v' ? 'y' : 'x', i*(w+m) - wDel/2);\n                frame.setAttribute(dir === 'v' ? 'x' : 'y', -wDel/2)\n                continue;\n            }\n            const tempChannel = inc*i;\n            const color = converter.getRGB[colorSpace](\n                Object.assign(\n                    {},\n                    COLOR[colorSpace],\n                    {[channel.name]: tempChannel})\n                );\n            blocks[i].setAttribute(\n                'fill',\n                `rgb(${color.red},${color.green},${color.blue})`,\n            );\n            blocks[i].setAttribute('stroke', 'transparent');\n        }\n    })\n\n    function resize(){\n        Object.assign(svg.style, {\n            height: target.getBoundingClientRect().height + 'px',\n        })\n    }\n    document.addEventListener('resize', resize);\n    resize();\n\n    Object.assign(svg.style, {\n        border: 'none',\n        borderRadius: 0,\n        boxShadow: 'none',\n        margin: 'none',\n    })\n    target.appendChild(svg);\n}","import mainColor from './ColorObject';\nimport namedColors from './namedColors';\nimport hsvFromRGB from './colorMethods/hsvFromRGB';\n\n\n\n\n\nfunction hexFromRGB(rgb) {\n    const color = [\n        Math.round(rgb.red).toString(16).split('.')[0],\n        Math.round(rgb.green).toString(16).split('.')[0],\n        Math.round(rgb.blue).toString(16).split('.')[0]\n    ];\n    const zeros = '00';\n    const result = '#' + color.map(color => zeros.slice(color.length) + color).join('');\n    return result;\n}\n\nconst channels = ['red','green','blue'];\n\n\nconst c1Lookup = {};\n\nfunction colorNameHSV(name){\n    if (c1Lookup[name]){\n        return c1Lookup[name];\n    }\n    c1Lookup[name] = hsvFromRGB({\n        red: parseInt(namedColors[name].slice(1, 3),16),\n        green: parseInt(namedColors[name].slice(3, 5),16),\n        blue: parseInt(namedColors[name].slice(5, 7),16)\n    });\n    return c1Lookup[name];\n}\n\nfunction closestNamedColor(color){\n    let best = null;\n    Object.keys(namedColors).forEach(k => {\n        const c1 = colorNameHSV(k);\n    \n        const c2 = hsvFromRGB(color);\n    \n        const hmin = Math.min(c1.hue, c2.hue);\n        const hmax = Math.max(c1.hue, c2.hue);\n        let hdiff = Math.min(hmax-hmin, hmin+360-hmax);\n        hdiff = isNaN(hdiff) ? 0 : hdiff;\n        const sdiff = isNaN(c1.saturation - c2.saturation) ? 0 : c1.saturation - c2.saturation;\n        const squareSum = (hdiff/360)**2*2 + (sdiff/100)**2 + ((c1.value - c2.value)/100)**2*2;\n\n        if (!best || best.distance > squareSum){\n            best = {\n                color: k,\n                distance: squareSum\n            }\n        }\n    })\n    return {\n        color: best.color,\n        distance: ((1 - Math.sqrt(best.distance/6))*100).toFixed(),\n    };\n}\n\n\n\nfunction mix(c1, c2, t){\n    return {\n        red: c1.red + (c2.red - c1.red)*t,\n        green: c1.green + (c2.green - c1.green)*t,\n        blue: c1.blue + (c2.blue - c1.blue)*t,\n    }\n}\n\n\nfunction isDark(rgb) {\n    return .2126*rgb.red + .7152*rgb.green + .0722*rgb.blue < .68*255;\n}\n\n\n\n\nconst inputStyle = `\n    font-size: 14px; \n    width: 32px; \n    color: inherit; \n    text-shadow: inherit; \n    border: none;\n`;\n\nconst opts = [\n    () => {\n        const closest = closestNamedColor(mainColor.color.rgb)\n        return `\n            <div style=\"display: flex; width: 100%; justify-content: space-between\">  \n            <div class=\"color-description\">\n                <div>${closest.color.toUpperCase()}</div>\n                <div>${closest.distance}% match</div>\n            </div>\n            </div>\n        `\n    },\n    () => {\n        const { color: { rgb: { red, green, blue } } } = mainColor;\n        return `\n            <div>\n            <span style=\"font-weight: 900; color: inherit;\">RGB(</span>\n            <input onInput=\"console.log(event.target.value)\" onClick=\"event.stopPropagation()\" style=\"${inputStyle}\" value='${Math.round(red)}'/>, \n            <input onInput=\"console.log(event.target.value)\" onClick=\"event.stopPropagation()\" style=\"${inputStyle}\" value='${Math.round(green)}'/>, \n            <input onInput=\"console.log(event.target.value)\" onClick=\"event.stopPropagation()\" style=\"${inputStyle}\" value='${Math.round(blue)}'/>\n            <span style=\"font-weight: 900; color: inherit;\">)</span>\n            </div>\n        `\n    }\n]\n\n\n\nexport default function makeColorPalette({target}) {\n    let showIdx = 0;\n    const currentColor = document.createElement('div');\n    currentColor.classList.add('current-color');\n    currentColor.addEventListener('click',()=>{\n        showIdx = (showIdx+1)%opts.length;\n        currentColor.innerHTML = opts[showIdx]();\n    })\n\n    target.appendChild(currentColor);\n    mainColor.subscribe(COLOR => {\n       const hexColor = hexFromRGB(COLOR.rgb);\n       currentColor.style.background = hexColor;\n       currentColor.classList.add(isDark(COLOR.rgb) ? 'dark' : 'light');\n       currentColor.classList.remove(isDark(COLOR.rgb) ? 'light' : 'dark');\n       currentColor.innerHTML = hexColor;\n       currentColor.innerHTML = opts[showIdx]();\n    })\n}\n\n{/* <button class=\"arrow\">&#9664;</button>\n <button class=\"arrow\">&#9654;</button> */}","import createSVG from './createSVG';\nimport mainColor from './ColorObject';\nimport allEqualExcept from './utils/allEqualExcept';\nimport methods from './colorMethods/index';\n\n\n\nconst paramLookup = {\n    cyan: 'C',\n    magenta: 'M',\n    yellow: 'Y',\n    black: 'K',\n    red: 'R',\n    green: 'G',\n    blue: 'B'\n}\n\nexport default function buildChannels(channels, {\n    trackLength = 300,\n    trackThickness = 8,\n    pipWidth = 12,\n    orientation = 'horizontal',\n    margin = 24,\n    outerMargin = 24,\n    spacing = 0,\n    recipient\n}){\n\n    const HH = outerMargin * 2 + margin * (channels.length-1) + trackThickness*(channels.length);\n    const WW = outerMargin * 2 + trackLength;\n\n    const div = document.createElement('div');\n    div.style.position = 'relative';\n    div.style[orientation === 'horizontal' ? 'width' : 'height'] = trackLength + 2*outerMargin + 2*spacing;\n    div.style[orientation === 'horizontal' ? 'height' : 'width'] = channels.length * trackThickness + (channels.length - 1)*margin + 2*outerMargin + 2*spacing;\n    div.style.display = 'flex';\n    div.style['justify-content'] = 'center';\n    div.style['align-items'] = 'flex-start';\n\n\n    const inputContainer = document.createElement('div');\n    inputContainer.classList.add('input-container');\n    inputContainer.style.margin = spacing + 'px';\n    \n\n    (recipient ? recipient : document.body).appendChild(div);\n\n\n    const container = createSVG('svg',{\n        [orientation === 'horizontal' ? 'width' : 'height']: trackLength + 2*outerMargin,\n        [orientation === 'horizontal' ? 'height' : 'width']: channels.length * trackThickness + (channels.length - 1)*margin + 2*outerMargin\n    })\n\n    Object.assign(container.style, {\n        marign: spacing,\n        display: 'block',\n        height: 'auto',\n        flexShrink: '0',\n    });\n\n    container.setAttribute('viewBox', `0 0 ${WW} ${HH}`);\n\n    div.appendChild(container);\n    div.appendChild(inputContainer);\n\n    let DIM_RATIO;\n    function resetRatio(){\n        DIM_RATIO = WW/container.getBoundingClientRect().width;\n    }\n    window.addEventListener('resize', resetRatio);\n    resetRatio();\n \n    channels.forEach((param,i) => {    \n        let maxValue;\n        switch (param.type){\n            case 'rgb':\n                maxValue = 255;\n                break;\n            default:\n                maxValue = 100;\n        }\n\n\n        const INPUT_HEIGHT = 24;\n        const input = document.createElement('input');\n        Object.assign(input.style, {\n            height: `${INPUT_HEIGHT}px`,\n            display: 'block',\n            position: 'absolute',\n            top: `${outerMargin/DIM_RATIO + i * (trackThickness + margin)/DIM_RATIO + (trackThickness/2)/DIM_RATIO - INPUT_HEIGHT/2}`,\n            margin: 0,\n        })\n\n\n        // const label = document.createElement('label');\n        // Object.assign(label.style, {\n        //     userSelect: 'none'\n        // })\n\n        Object.assign(inputContainer.style, {\n            userSelect: 'none',\n            height: `${HH/DIM_RATIO}px`,\n            position: 'absolute',\n            right: '16px',\n        })\n\n        // label.innerHTML = paramLookup[param.channel];\n        // inputContainer.appendChild(label);\n        inputContainer.appendChild(input);\n        let lastValid = 0;\n        \n        mainColor.subscribe((COLOR, PREV) => {\n            lastValid = COLOR[param.type][param.channel];\n            const value = Math.round(COLOR[param.type][param.channel] * 10)/10;\n            if (document.activeElement !== input) input.value = value.toFixed(1);\n        })\n\n        input.addEventListener('input',e => {\n            e.preventDefault();\n            if (isNaN(+input.value) || +input.value < 0 || +input.value > maxValue) return;\n            mainColor.set(\n                param.type,\n                { [param.channel]: +input.value }\n            )\n        })\n\n        input.addEventListener('blur',()=>{\n            input.value = lastValid.toFixed(1)\n        })\n\n        const gradient = createSVG('linearGradient',{\n            [orientation === 'horizontal' ? 'x1' : 'y1' ]: pipWidth/2 + outerMargin,\n            [orientation === 'horizontal' ? 'x2' : 'y2' ]: trackLength-pipWidth/2 + outerMargin,\n            [orientation === 'horizontal' ? 'y1' : 'x1' ]: 0,\n            [orientation === 'horizontal' ? 'y2' : 'x2' ]: 0,\n            gradientUnits: 'userSpaceOnUse',\n        })\n\n        const stop1 = createSVG('stop',{\n            offset: 0,\n            'stop-color': 'black', //TODO: initialize\n        })\n\n        const stop2 = createSVG('stop',{\n            offset: .5,\n            'stop-color': 'red', //TODO: initialize\n        })\n\n        const stop3 = createSVG('stop',{\n            offset: 1,\n            'stop-color': 'red', //TODO: initialize\n        })\n\n        const track_ = createSVG('rect',{\n            [ orientation === 'horizontal' ? 'width' : 'height']: trackLength,\n            [ orientation === 'horizontal' ? 'height' : 'width']: trackThickness,\n            [ orientation === 'horizontal' ? 'y' : 'x']: (trackThickness + margin)*i + outerMargin,\n            [ orientation === 'horizontal' ? 'x' : 'y']: outerMargin,\n            rx: 2,\n            fill: `url(#${gradient.id})`\n        })\n\n        const pip_ = createSVG('rect',{\n            [ orientation === 'horizontal' ? 'height' : 'width']: trackThickness + 2,\n            [ orientation === 'horizontal' ? 'width' : 'height']: pipWidth,\n            fill: 'transparent',\n            [ orientation === 'horizontal' ? 'y' : 'x']: (trackThickness + margin)*i - 1 + outerMargin,\n            stroke: 'white',\n            'stroke-width': 2,\n            'vector-effect': 'non-scaling-stroke',\n            filter: 'url(#shadow)',\n            rx: 2\n        })\n\n        gradient.appendChild(stop1);\n        gradient.appendChild(stop2);\n        gradient.appendChild(stop3);\n\n        container.appendChild(gradient);\n        container.appendChild(track_);\n        container.appendChild(pip_);\n\n        mainColor.subscribe((COLOR, PREV)=>{  \n            if (\n                COLOR[param.type][param.channel] !==\n                PREV[param.type][param.channel]\n            ) pip_.setAttribute(\n                orientation === 'horizontal' ? 'x' : 'y',\n                orientation === 'horizontal' ?\n                    COLOR[param.type][param.channel]/maxValue*(trackLength-pipWidth) + outerMargin :\n                    (1-COLOR[param.type][param.channel]/maxValue)*(trackLength-pipWidth) + outerMargin\n            );\t\t\n\n            if (allEqualExcept(\n                param.channel,\n                COLOR[param.type],\n                PREV[param.type],\n            )) return;\n            \n\n            let left;\n            let middle;\n            let right;\n\n            const base = COLOR[param.type]\n            if (param.type !== 'rgb'){\n                left = methods.getRGB[param.type]({...base, [param.channel]: 0 });\n                right = methods.getRGB[param.type]({...base, [param.channel]: maxValue });\n                middle = methods.getRGB[param.type]({...base, [param.channel]: maxValue/2});\n            } else {\n                left = { ...base , [param.channel]: 0  }\n                right = { ...base , [param.channel]: maxValue }\n                middle = { ...base , [param.channel]: maxValue/2 }\n            }\n\n        const l = `rgb(${left.red},${left.green},${left.blue})`;\n        const m = `rgb(${middle.red},${middle.green},${middle.blue})`;\n        const r = `rgb(${right.red},${right.green},${right.blue})`;\n        \n        \n        stop1.setAttribute('stop-color', orientation === \"horizontal\" ? l : r);\n        stop2.setAttribute('stop-color', m);\n        stop3.setAttribute('stop-color', orientation === \"horizontal\" ? r : l);\n    })\n    \n    \n    pip_.addEventListener('mousedown',e=>{\n        let x = orientation === 'horizontal' ? e.clientX : e.clientY;\n        let rawProgress = mainColor.color[param.type][param.channel];\n        \n        function move(e){\n            const newX = orientation === 'horizontal' ? e.clientX : e.clientY;\n            const delx = DIM_RATIO*(orientation === 'horizontal' ? newX - x : x - newX); //note need to scale if svg space is diff from user space;\n            rawProgress += delx/(trackLength-pipWidth)*maxValue;\n            \n            let newVal = Math.min(rawProgress, maxValue);\n            newVal = Math.max(newVal, 0);\n            mainColor.set(param.type,{[param.channel]: newVal});\n            x = orientation === 'horizontal' ? e.clientX : e.clientY;\n        }\n        \n        document.addEventListener('mousemove',move);\n        document.addEventListener('mouseup',()=>{\n            document.removeEventListener('mousemove',move);\n        },{once:true})\t\n    })\t\n})\n}","import mainColor from './ColorObject';\nimport triFromRGB from './colorMethods/triFromRGB';\nimport createSVG from './createSVG';\nimport ns from './constants';\nimport triangleGradient from './gradientGenerators/triangleGradient';\nimport pureFromHue from './colorMethods/pureFromHue';\n\nconst sq3 = Math.sqrt(3);\nlet pip;\nlet l1;\nlet l2;\nlet l3;\nlet input1;\nlet input2;\nlet input3;\n\nconst ratio = sq3 / 2;\nconst margin = 10;\n\nlet SIDE = 180;\nlet RECT_WIDTH = SIDE + margin * 2;\nlet RECT_HEIGHT = Math.ceil(SIDE * ratio + margin * 2);\nlet X_TRANS = -SIDE / 2 / sq3 - margin + 100 / 2;\nlet Y_TRANS = RECT_WIDTH + (100 - RECT_WIDTH) / 2;\nlet TRIANGLE_HEIGHT = SIDE * ratio;\n\nconst pattern = triangleGradient({\n  width: RECT_WIDTH,\n  height: RECT_HEIGHT,\n  side: SIDE,\n  margin,\n});\n\nexport default function make(target) {\n  const container = document.createElement('div');\n  Object.assign(container.style, {\n    width: `${RECT_WIDTH}px`,\n    height: `${RECT_HEIGHT}px`,\n  });\n\n  const svg = createSVG('g', {});\n  const body = createSVG('g', {});\n  const defs = createSVG('defs', {});\n  const clip = createSVG('clipPath', {});\n  const clippath = createSVG('path', {});\n  const r = createSVG('rect', {});\n\n  l1 = createSVG('line', {\n    stroke: 'white',\n    'stroke-width': 0.5,\n  });\n\n  l2 = createSVG('line', {\n    stroke: 'white',\n    'stroke-width': 0.5,\n  });\n\n  l3 = createSVG('line', {\n    stroke: 'white',\n    'stroke-width': 0.5,\n  });\n\n  input1 = document.createElement('input');\n  input1.addEventListener('input', setChannel('color'));\n  input1.addEventListener('blur', setFromLastValid('color'));\n\n  input2 = document.createElement('input');\n  input2.addEventListener('input', setChannel('white'));\n  input2.addEventListener('blur', setFromLastValid('white'));\n\n  input3 = document.createElement('input');\n  input3.addEventListener('input', setChannel('black'));\n  input3.addEventListener('blur', setFromLastValid('black'));\n\n  [input1, input2, input3].forEach((i) => {\n    Object.assign(i.style, {\n      position: 'absolute',\n      margin: 0,\n    });\n  });\n\n  input1.style.transform = 'translateX(-100%)translateY(50%)';\n  input2.style.transform = 'translateY(100%)';\n\n  target.appendChild(input1);\n  target.appendChild(input2);\n  target.appendChild(input3);\n\n  ns.hueSlider.get().appendChild(svg);\n  svg.appendChild(defs);\n  svg.appendChild(body);\n  defs.appendChild(pattern);\n  defs.appendChild(clip);\n  clip.appendChild(clippath);\n\n  r.setAttribute('clip-path', `url(#${clip.id})`);\n  r.setAttribute('fill', `url(#${pattern.id})`);\n  r.setAttribute('filter', 'url(#shadow2)');\n  const g = createSVG('g', {});\n  body.appendChild(g);\n  g.appendChild(r);\n\n  pip = createSVG('circle', {});\n  body.appendChild(l1);\n  body.appendChild(l2);\n  body.appendChild(l3);\n  body.appendChild(pip);\n\n  pip.setAttribute('r', 5);\n  pip.setAttribute('cx', margin);\n  pip.setAttribute('cy', margin);\n  pip.setAttribute('stroke', 'white');\n  pip.setAttribute('fill', 'transparent');\n  pip.setAttribute('vector-effect', 'non-scaling-stroke');\n  pip.setAttribute('filter', 'url(#shadow2)');\n\n  function resize() {\n    const { height } = target.getBoundingClientRect();\n    SIDE = height / 2;\n    RECT_WIDTH = SIDE + margin * 2;\n    RECT_HEIGHT = Math.ceil(SIDE * ratio + margin * 2);\n    X_TRANS = -SIDE / 2 / sq3 - margin + height / 2;\n    Y_TRANS = RECT_WIDTH + (height - RECT_WIDTH) / 2;\n    TRIANGLE_HEIGHT = SIDE * ratio;\n\n    clippath.setAttribute('d', `\n    M ${margin} 0 \n    l ${SIDE} 0 \n    a ${margin} ${margin} 0 0 1 ${margin * Math.sin(Math.PI / 3)} ${margin + margin * Math.cos(Math.PI / 3)}\n    l ${-SIDE / 2} ${SIDE * ratio} \n    a ${margin} ${margin} 0 0 1 ${-margin * 2 * Math.sin(Math.PI / 3)} 0\n    l ${-SIDE / 2} ${-SIDE * ratio}\n    A ${margin} ${margin} 0 0 1 ${margin} 0\n  `);\n\n    r.setAttribute('height', RECT_HEIGHT);\n    r.setAttribute('width', RECT_WIDTH);\n    r.style.outline = '1px solid red';\n    setTriangle(mainColor.color);\n\n    body.setAttribute('transform', `translate(${X_TRANS} ${Y_TRANS})rotate(-90)`);\n  }\n\n  resize();\n  window.addEventListener('resize', resize);\n\n  let lastValidTri = null;\n\n  mainColor.subscribe(setTriangle);\n\n  mainColor.subscribe((COLOR) => {\n    lastValidTri = triFromRGB(COLOR.rgb);\n  });\n\n  function setFromLastValid(channel) {\n    return function (e) {\n      e.target.value = Math.abs(lastValidTri[channel] * 100).toFixed(1);\n    };\n  }\n\n  pip.addEventListener('mousedown', setPip);\n}\n\nfunction setPip(e) {\n  let x = e.clientX;\n  let y = e.clientY;\n\n  const pure = pureFromHue(mainColor.color.hsv.hue % 360);\n  function move(e) {\n    const dely = (e.clientX - x);\n    const delx = -(e.clientY - y);\n\n    let xAttempt = pip.cx.baseVal.value + delx;\n    let yAttempt = pip.cy.baseVal.value + dely;\n\n    if (yAttempt - margin > SIDE * ratio) {\n      // tip of triangle\n      yAttempt = SIDE * ratio + margin;\n      xAttempt = SIDE / 2 + margin;\n      console.log('top');\n    }\n\n    if ((yAttempt - margin) < 0) {\n      yAttempt = margin;\n      console.log('bottom');\n    }\n\n    if ((xAttempt - margin) < 0) {\n      xAttempt = margin;\n      console.log('left');\n    }\n\n    if ((xAttempt - margin) > SIDE) {\n      console.log('right');\n      xAttempt = SIDE + margin;\n    }\n\n    if ((yAttempt - margin) > (xAttempt - margin) * Math.sqrt(3)) {\n      if (-Math.sqrt(3) * dely > delx) {\n        yAttempt = (xAttempt - margin) * Math.sqrt(3) + margin;\n      } else {\n        xAttempt = (yAttempt - margin) / Math.sqrt(3) + margin;\n      }\n    }\n\n    if ((yAttempt - margin) > (xAttempt - margin - SIDE) * -Math.sqrt(3)) {\n      if (Math.sqrt(3) * dely > delx) {\n        xAttempt = (yAttempt - margin) / -Math.sqrt(3) + margin + SIDE;\n      } else {\n        yAttempt = (xAttempt - margin - SIDE) * -Math.sqrt(3) + margin;\n      }\n    }\n\n    const yy = yAttempt - margin;\n    const xx = xAttempt - margin;\n\n    pip.setAttribute('cy', yy + margin);\n    pip.setAttribute('cx', xx + margin);\n\n    const top = yy / TRIANGLE_HEIGHT;\n    const left = (xx * Math.sqrt(3) - yy) / TRIANGLE_HEIGHT / 2;\n\n    const newColor = {\n      red: pure.red * top + 255 * left,\n      green: pure.green * top + 255 * left,\n      blue: pure.blue * top + 255 * left,\n    };\n\n    mainColor.set('rgb', newColor);\n\n    x = e.clientX;\n    y = e.clientY;\n  }\n\n  document.addEventListener('mousemove', move);\n  document.addEventListener('mouseup', () => {\n    document.removeEventListener('mousemove', move);\n  }, { once: true });\n}\n\nfunction setTriangle(COLOR, PREV) {\n  const tri = triFromRGB(COLOR.rgb);\n  if (!PREV || COLOR.hsv.saturation !== PREV.hsv.saturation || COLOR.hsv.value !== PREV.hsv.value) {\n    const y = tri.color * SIDE * ratio;\n    // most obvious; move as a percentage of s*ratio units away from x axis.\n\n    const ym = y + margin;\n\n    pip.setAttribute('cy', ym);\n    const xP = sq3 / 2 * tri.white * SIDE * ratio;\n    // find unit vector with slope perpindicular to sqrt(3), then multiply by s*ratio.\n    // this gives a point that is the correct number of units away from the WHITE vertex.\n    // Make a line with slope of sqrt(3) intersecting this point using the point-slope formula.\n    // Find where this line intersects y = tri.color*s*ratio.\n    const yP = -1 / 2 * tri.white * SIDE * ratio;\n    const x = (y - yP) / sq3 + xP;\n    const xm = x + margin;\n    pip.setAttribute('cx', xm);\n\n    l1.setAttribute('y2', ym);\n    l1.setAttribute('x1', xm);\n    l1.setAttribute('x2', xm);\n\n    const mm1 = margin + 3 * margin / sq3;\n    const xx1 = (sq3 * (SIDE + mm1) + 1 / sq3 * (xm) - ym) / (1 / sq3 + sq3);\n    const yy1 = -sq3 * (xx1 - (SIDE + mm1));\n\n    const mm2 = margin - sq3 * margin / 2 - 3 / 2 * margin / sq3;\n    const xx2 = (1 / sq3 * xm + ym + sq3 * mm2) / (1 / sq3 + sq3);\n    const yy2 = sq3 * (xx2 - mm2);\n\n    l2.setAttribute('x1', x + margin);\n    l2.setAttribute('y1', y + margin);\n    l2.setAttribute('x2', xx1);\n    l2.setAttribute('y2', yy1);\n\n    input3.style.left = `${yy1 + X_TRANS}px`;\n    input3.style.bottom = `${xx1 + Y_TRANS - RECT_WIDTH}px`;\n\n    input2.style.left = `${yy2 + X_TRANS}px`;\n    input2.style.bottom = `${xx2 + Y_TRANS - RECT_WIDTH}px`;\n\n    input1.style.left = `${0 + X_TRANS}px`;\n    input1.style.bottom = `${xm + Y_TRANS - RECT_WIDTH}px`;\n\n    if (document.activeElement !== input1) input1.value = Math.abs(tri.color * 100).toFixed(1);\n    if (document.activeElement !== input2) input2.value = Math.abs(tri.white * 100).toFixed(1);\n    if (document.activeElement !== input3) input3.value = Math.abs(tri.black * 100).toFixed(1);\n\n    l3.setAttribute('x1', x + margin);\n    l3.setAttribute('y1', y + margin);\n    l3.setAttribute('x2', xx2);\n    l3.setAttribute('y2', yy2);\n  }\n}\n\nfunction setChannel(channel) {\n  return function (e) {\n    e.preventDefault();\n    if (isNaN(+e.target.value) || +e.target.value > 100 || +e.target.value < 0) return;\n    const tri = triFromRGB(mainColor.color.rgb);\n    const newVal = +e.target.value;\n    tri[channel] = 0;\n    const denom = Object.values(tri).reduce((a, l) => a + l, 0);\n    const newTri = {\n      white: (100 - newVal) * (denom ? tri.white / denom : 1),\n      color: (100 - newVal) * (denom ? tri.color / denom : 1),\n      black: (100 - newVal) * (denom ? tri.black / denom : 1),\n    };\n    newTri[channel] = newVal;\n\n    const { hue } = mainColor.color.hsv;\n    const rgb = pureFromHue(hue % 360);\n\n    mainColor.set('rgb', {\n      red: (rgb.red * newTri.color + 0 * newTri.black + 255 * newTri.white) / 100,\n      green: (rgb.green * newTri.color + 0 * newTri.black + 255 * newTri.white) / 100,\n      blue: (rgb.blue * newTri.color + 0 * newTri.black + 255 * newTri.white) / 100,\n    });\n  };\n}\n","export default function allEqualExcept(key, obj1, obj2){\n    const keys = Object.keys(obj1 || {});\n    if (Object.keys(obj2 || {}).length !== keys.length) return false;\n    for (let i=0; i<keys.length; i++){\n        if (key === keys[i]) continue;\n        if (obj1[keys[i]] !== obj2[keys[i]]) return false;\n    }\n    return true;\n}","export default function extrema(obj){\n\tlet max = null;\n\tlet min = null;\n\tObject.keys(obj).forEach(channel => {\n\t\tif (!min) min = channel;\n\t\tif (!max) max = channel;\n\t\tif (obj[channel] < obj[min]) min = channel;\n\t\tif (obj[channel] > obj[max]) max = channel;\n\t});\n\treturn {max, min};\n}","export default function isEqual(obj,obj2){\n\tconst keys1 = Object.keys(obj || {});\n\tconst keys2 = Object.keys(obj2 || {});\n\tif (keys1.length !== keys2.length) return false;\n\tfor (let i=0; i<keys1.length; i++){\n\t\tif (obj[keys1[i]] !== obj2[keys1[i]]) return false;\n\t}\n\treturn true;\n}\n","export default \"// an attribute will receive data from a buffer\\nattribute vec4 a_position;\\nvarying vec2 v_pos;\\n\\n// all shaders have a main function\\nvoid main() {\\n\\n    // gl_Position is a special variable a vertex shader\\n    // is responsible for setting\\n    gl_Position = a_position;\\n    v_pos = vec2(a_position);\\n}\";","export default \"precision mediump float;\\nvarying vec2 v_pos;\\nuniform float u_saturation;\\nuniform float u_lightness;\\n\\n\\nfloat floatMod(float a, float b){\\n    return a - floor(a/b) * b;\\n}\\n\\nvec3 rgb_hsl(vec3 hsl){\\n    float C = (1.0 - abs(2.0*hsl.z- 1.0))*hsl.y;\\n    float H = hsl.x*6.0;\\n    float X = C * (1.0 - abs(floatMod(H, 2.0)-1.0));\\n    float m = hsl.z - C/2.0;\\n\\n    if (H == 6.0 || H < 1.0) {\\n        return vec3(C + m, X + m, m);\\n    } else if (H < 2.0) {\\n        return vec3(X + m, C + m, m);\\n    } else if (H < 3.0) {\\n        return vec3(m, C + m, X + m);\\n    } else if (H < 4.0) {\\n        return vec3(m, X + m, C + m);\\n    } else if (H < 5.0) {\\n        return vec3(X + m, m, C + m);\\n    } else {\\n        return vec3(C + m, m, X + m);\\n    }\\n}\\n\\nfloat frac(float x) {\\n    return x - floor(x);\\n}\\n\\nvoid main() {\\n    float pi = 3.14159265359;\\n\\n    float y = v_pos.y;\\n    float x = v_pos.x;\\n\\n    float angle = atan(x/y);\\n    if (y < 0.0) angle = pi + angle;\\n\\tif (x < 0.0 && y >= 0.0) angle = 2.0*pi + angle;\\n\\n    \\n    float hue = angle/(2.0*pi);\\n    gl_FragColor = vec4(\\n        rgb_hsl(vec3(hue, u_saturation, u_lightness)), \\n        1.0\\n    );\\n}\";","export default \"precision mediump float;\\nvarying vec2 v_pos;\\nuniform vec2 u_res;\\nuniform int u_colorspace;\\nuniform int u_chan;\\nuniform vec3 u_color;\\nuniform float u_padding;\\n\\nfloat floatMod(float a, float b){\\n    return a - floor(a/b) * b;\\n}\\n\\n//HSL u_colorspace == 0\\nvec3 rgb_hsl(vec3 hsl){\\n    float C = (1.0 - abs(2.0*hsl.z- 1.0))*hsl.y;\\n    float H = hsl.x*6.0;\\n    float X = C * (1.0 - abs(floatMod(H, 2.0)-1.0));\\n    float m = hsl.z - C/2.0;\\n\\n    if (H == 6.0 || H < 1.0) {\\n        return vec3(C + m, X + m, m);\\n    } else if (H < 2.0) {\\n        return vec3(X + m, C + m, m);\\n    } else if (H < 3.0) {\\n        return vec3(m, C + m, X + m);\\n    } else if (H < 4.0) {\\n        return vec3(m, X + m, C + m);\\n    } else if (H < 5.0) {\\n        return vec3(X + m, m, C + m);\\n    } else {\\n        return vec3(C + m, m, X + m);\\n    }\\n}\\n\\n// //HSV u_colorspace == 1\\nvec3 rgb_hsv(vec3 hsv){\\n\\n    float H = hsv.x*6.0;\\n\\n\\tfloat progress = floatMod(H, 1.0);\\n\\tif (floatMod(floor(H),2.0) == 1.0){\\n\\t\\tprogress = 1.0 - progress;\\n\\t};\\n\\t\\n\\tfloat maxval = hsv.z;\\n\\tfloat minval = (1.0 - hsv.y) * maxval;\\n\\tfloat midval = minval + (maxval - minval)*progress;\\n\\n    vec3 max2min = vec3(maxval, midval, minval);\\n\\n    if (H == 6.0 || H < 1.0) {\\n        return max2min.rgb;\\n    } else if (H < 2.0) {\\n        return max2min.grb;\\n    } else if (H < 3.0) {\\n        return max2min.brg;\\n    } else if (H < 4.0) {\\n        return max2min.bgr;\\n    } else if (H < 5.0) {\\n        return max2min.gbr;\\n    } else {\\n        return max2min.rbg;\\n    }\\n}\\n\\n\\nvec3 assign(vec3 color, int chan, float new_value) {\\n  vec3 new_color = color.xyz;\\n  if (chan == 0) {\\n      new_color.x = new_value;\\n  } else if (chan == 1){\\n      new_color.y = new_value;\\n  } else if (chan == 2) {\\n      new_color.z = new_value;\\n  }\\n  return new_color;\\n}\\n\\nvoid main() {\\n    float val = ((v_pos.y + 1.0)/2.0*u_res.y - u_padding)/(u_res.y-2.0*u_padding);\\n    val = min(1.0,val);\\n    val = max(0.0,val);\\n\\n    vec3 new_color = assign(u_color, u_chan, val);\\n    if (u_colorspace == 0) {\\n        gl_FragColor = vec4(rgb_hsl(new_color),1);\\n    } else if (u_colorspace == 1) {\\n        gl_FragColor = vec4(rgb_hsv(new_color),1);\\n    } else {\\n        gl_FragColor = vec4(1,0,0,1);\\n    }\\n}\\n\";","export default \"precision mediump float;\\nvarying vec2 v_pos;\\nuniform vec2 u_res;\\nuniform vec3 u_color;\\nuniform float u_side;\\nuniform float u_margin;\\n\\nvoid main() {\\n   float sq3 = 1.732050807568877;\\n   float ratio = sq3/2.0;\\n   float h = u_side * ratio;\\n   vec3 black = vec3(0.0, 0.0, 0.0);\\n   vec3 white = vec3(1.0, 1.0, 1.0);\\n\\n   float x = (v_pos.x + 1.0)/2.0 * u_res.x - u_margin;\\n   float y = (1.0 - (v_pos.y + 1.0)/2.0) * u_res.y - u_margin;\\n\\n   float top = y/h;\\n   float left = (x*sq3 - y)/h/2.0;\\n   float right = ((x-u_side)*-sq3 -y)/h/2.0;\\n\\n   \\tif (y < sq3*x && y < (x-u_side)*-sq3 && y > 0.0){\\n      gl_FragColor = vec4(top*u_color + left*white + right*black, 1.0);\\n    } else if (y <= 0.0) {\\n \\t    gl_FragColor = vec4(x/u_side*white + (1.0-x/u_side)*black, 1.0);\\n    } else if (x > u_side/2.0 && y > 0.0){\\n      float w = min((-(x-u_side)/2.0 + ratio*y)/u_side,1.0);\\n      gl_FragColor = vec4((1.0-w)*white + w*u_color, 1.0);\\n    } else {\\n      float w = min((x/2.0 + ratio*y)/u_side, 1.0);\\n      gl_FragColor = vec4((1.0-w)*black + w*u_color, 1);\\n    }\\n}\\n\\n\";","export default \"precision mediump float;\\nvarying vec2 v_pos;\\nuniform vec2 u_res;\\nuniform float u_z;\\nuniform int u_colorspace;\\nuniform ivec3 u_ord;\\nuniform float u_padding;\\n\\nfloat floatMod(float a, float b){\\n    return a - floor(a/b) * b;\\n}\\n\\n//HSL u_colorspace == 0\\nvec3 rgb_hsl(vec3 hsl){\\n    float C = (1.0 - abs(2.0*hsl.z- 1.0))*hsl.y;\\n    float H = hsl.x*6.0;\\n    float X = C * (1.0 - abs(floatMod(H, 2.0)-1.0));\\n    float m = hsl.z - C/2.0;\\n\\n    if (H == 6.0 || H < 1.0) {\\n        return vec3(C + m, X + m, m);\\n    } else if (H < 2.0) {\\n        return vec3(X + m, C + m, m);\\n    } else if (H < 3.0) {\\n        return vec3(m, C + m, X + m);\\n    } else if (H < 4.0) {\\n        return vec3(m, X + m, C + m);\\n    } else if (H < 5.0) {\\n        return vec3(X + m, m, C + m);\\n    } else {\\n        return vec3(C + m, m, X + m);\\n    }\\n}\\n\\n//HSV u_colorspace == 1\\nvec3 rgb_hsv(vec3 hsv){\\n\\n    float H = hsv.x*6.0;\\n\\n\\tfloat progress = floatMod(H, 1.0);\\n\\tif (floatMod(floor(H),2.0) == 1.0){\\n\\t\\tprogress = 1.0 - progress;\\n\\t};\\n\\t\\n\\tfloat maxval = hsv.z;\\n\\tfloat minval = (1.0 - hsv.y) * maxval;\\n\\tfloat midval = minval + (maxval - minval)*progress;\\n\\n    vec3 max2min = vec3(maxval, midval, minval);\\n\\n    if (H == 6.0 || H < 1.0) {\\n        return max2min.rgb;\\n    } else if (H < 2.0) {\\n        return max2min.grb;\\n    } else if (H < 3.0) {\\n        return max2min.brg;\\n    } else if (H < 4.0) {\\n        return max2min.bgr;\\n    } else if (H < 5.0) {\\n        return max2min.gbr;\\n    } else {\\n        return max2min.rbg;\\n    }\\n}\\n\\n\\nvec3 swizzle(vec3 channels, ivec3 u_ord) {\\n    if (u_ord.x == 0 && u_ord.y == 1 && u_ord.z == 2) {\\n        return channels.xyz;\\n    } else if (u_ord.x == 0 && u_ord.y == 2 && u_ord.z == 1) {\\n        return channels.xzy;\\n    } else if (u_ord.x == 1 && u_ord.y == 0 && u_ord.z == 2) {\\n        return channels.yxz;\\n    } else if (u_ord.x == 1 && u_ord.y == 2 && u_ord.z == 0) {\\n        return channels.zxy;\\n    } else if (u_ord.x == 2 && u_ord.y == 0 && u_ord.z == 1) {\\n        return channels.yzx;\\n    } else {\\n        return channels.zyx;\\n    }\\n}\\n\\nvoid main() {\\n    float x = (v_pos.x + 1.0)/2.0*u_res.x - u_padding;\\n    x = max(x, 0.0);\\n    x = min(x, u_res.x - 2.0*u_padding);\\n    \\n    float x_unit = x/(u_res.x - 2.0*u_padding);\\n\\n    float y = (1.0 + v_pos.y)/2.0*u_res.y - u_padding;\\n    y = max(y, 0.0);\\n    y = min(y, u_res.y - 2.0*u_padding);\\n\\n    float y_unit = y/(u_res.y - 2.0*u_padding);\\n\\n    vec3 rgb;\\n\\n    //manually swizzle the channels\\n    vec3 channels = vec3(x_unit, y_unit, u_z);\\n \\n    vec3 newChannels = swizzle(channels, u_ord);\\n\\n    if (u_colorspace == 0) {\\n        rgb = rgb_hsl(newChannels);\\n    } else if (u_colorspace == 1) {\\n        rgb = rgb_hsv(newChannels);\\n    } else {\\n        rgb = vec3(1.0,0.0,0.0);\\n    }\\n    gl_FragColor = vec4(rgb, 1.0);\\n}\\n\";","import vertexScript from './shaders/basicVertexShader.glsl';\nimport triangleGradient from './shaders/triangleGradient.glsl';\nimport gradient1D from './shaders/gradient1D.glsl';\n\n//TODO turn triangleGradient and gradient1D into classes in /gradientGenerators\n//TODO create a superclass for gradients\nexport function drawVertices(gl, program, positionAttribute) {\n    const position = gl.getAttribLocation(program, positionAttribute);\n    const positionBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n    const positions = [\n        -1, -1,\n        1, -1,\n        1,  1,\n        1,  1,\n        -1, 1,\n        -1, -1,\n      ];\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(position);\n    gl.vertexAttribPointer(position, 2, gl.FLOAT, false, 0, 0);\n    gl.drawArrays(gl.TRIANGLES, 0, 6);\n}\n\nexport function clear(gl){\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n    gl.clearColor(0, 0, 0, 0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n}\n\nexport function createShader(gl, type, source) {\n    const shader = gl.createShader(type);\n    if (!shader) throw new Error('Could not create shader');\n\n    gl.shaderSource(shader, source);\n    gl.compileShader(shader);\n    const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n    if (success) {\n        return shader;\n    }\n\n    gl.deleteShader(shader);\n    throw new Error(`Could not create shader: ${gl.getShaderInfoLog(shader)}`)\n}\n\nexport function createProgram(gl, vertexShader, fragmentShader) {\n    var program = gl.createProgram();\n    if (!program) throw new Error('Could not create program');\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragmentShader);\n    gl.linkProgram(program);\n    var success = gl.getProgramParameter(program, gl.LINK_STATUS);\n    if (success) {\n      return program;\n    }\n   \n    gl.deleteProgram(program);\n    throw new Error(`Could not create program: ${gl.getProgramInfoLog(program)}`);\n}","import createSVG from './createSVG';\nimport mainColor from './ColorObject';\nimport { CHAN_MAX } from './colorMathConstants';\nimport xyGradient from './gradientGenerators/xyGradient';\nimport linearGradient from './gradientGenerators/linearGradient';\n\nconst SLIDER_PIP_WIDTH = 22;\nconst SLIDER_PIP_HEIGHT = 8;\nconst XY_SLIDER_PADDING = 0;\n\nexport default function makeXYSlider({\n  xChannel,\n  yChannel,\n  zChannel,\n  colorSpace,\n  height = 150,\n  width = 250,\n  trackWidth = 20,\n  spaceBetween = 10,\n  outerMargin = 20,\n  target,\n}) {\n  const xMax = CHAN_MAX[colorSpace][xChannel];\n  const yMax = CHAN_MAX[colorSpace][yChannel];\n  const zMax = CHAN_MAX[colorSpace][zChannel];\n\n  if (!target) target = document.body;\n\n  let DIM_RATIO;\n  let lastValid;\n\n  const SVG_WIDTH = width + trackWidth + spaceBetween + outerMargin * 2;\n  const SVG_HEIGHT = outerMargin * 2 + height;\n\n  // const pattern = makePattern();\n  // const image = pattern.getElementsByTagName('image')[0];\n  const xyGradientPattern = xyGradient({\n    height,\n    width,\n    padding: XY_SLIDER_PADDING,\n    colorSpace,\n    xChannel,\n    yChannel,\n    zChannel,\n  });\n  const defs = createSVG('defs', {});\n  const xySVG = createSVG('rect', {\n    height,\n    width,\n    rx: XY_SLIDER_PADDING,\n    fill: `url(#${xyGradientPattern.id})`,\n  });\n  const svg = createSVG('svg', {\n    viewBox: `0 0 ${SVG_WIDTH} ${SVG_HEIGHT}`,\n  });\n\n  Object.assign(svg.style, {\n    height: '192px',\n    width: 'auto',\n    display: 'block',\n    flexShrink: 0,\n  });\n\n\n  const body = createSVG('g', {\n    transform: `translate(${outerMargin} ${outerMargin})`,\n  });\n\n  const linearGradientPattern = linearGradient({\n    height,\n    width: 1,\n    colorSpace,\n    channel: zChannel,\n    padding: SLIDER_PIP_HEIGHT / 2,\n  });\n\n  const pip = createSVG('circle', {\n    r: 5,\n    stroke: 'white',\n    fill: 'transparent',\n    filter: 'url(#shadow)',\n  });\n\n  const v = createSVG('line', {\n    y1: 0,\n    y2: height,\n    stroke: 'white',\n    'stroke-width': 0.5,\n  });\n  const inputX = document.createElement('input');\n  Object.assign(inputX.style, {\n    position: 'absolute',\n    margin: 0,\n    transform: 'translateX(-50%)',\n    bottom: 0,\n  });\n  inputX.addEventListener('input', (e) => {\n    e.preventDefault();\n    if (isNaN(+inputX.value) || +inputX.value < 0 || +inputX.value > xMax) return;\n    mainColor.set(\n      colorSpace,\n      { [xChannel]: +inputX.value },\n    );\n  });\n  inputX.addEventListener('blur', () => {\n    inputX.value = lastValid.x.toFixed(1);\n  });\n\n  const h = createSVG('line', {\n    x1: 0,\n    x2: width,\n    stroke: 'white',\n    'stroke-width': 0.5,\n  });\n  const inputY = document.createElement('input');\n  inputY.addEventListener('input', (e) => {\n    e.preventDefault();\n    if (isNaN(+inputY.value) || +inputY.value < 0 || +inputY.value > yMax) return;\n    mainColor.set(\n      colorSpace,\n      { [yChannel]: +inputY.value },\n    );\n  });\n  inputY.addEventListener('blur', () => {\n    inputY.value = lastValid.y.toFixed(1);\n  });\n\n  const inputZ = document.createElement('input');\n\n  const sliderPip = createSVG('rect', {\n    height: SLIDER_PIP_HEIGHT,\n    width: SLIDER_PIP_WIDTH,\n    stroke: 'white',\n    filter: 'url(#shadow)',\n    x: width + spaceBetween + (trackWidth - SLIDER_PIP_WIDTH) / 2,\n    fill: 'transparent',\n  });\n\n  sliderPip.addEventListener('mousedown', (e) => {\n    let y = e.clientY;\n    function move(e) {\n      const delY = (y - e.clientY) / (height - SLIDER_PIP_HEIGHT)*zMax * DIM_RATIO;\n      const yAttempt = mainColor.color[colorSpace][zChannel] + delY;\n      let newY = Math.min(zMax, yAttempt);\n      newY = Math.max(newY, 0);\n      mainColor.set(colorSpace, {\n        [zChannel]: newY,\n      });\n      if (newY === yAttempt) y = e.clientY;\n    }\n    document.addEventListener('mousemove', move);\n    document.addEventListener('mouseup', () => {\n      document.removeEventListener('mousemove', move);\n    }, { once: true });\n  });\n\n  mainColor.subscribe((COLOR, PREV) => {\n    const y = (1 - (COLOR[colorSpace][zChannel] / zMax)) * (height - SLIDER_PIP_HEIGHT);\n    sliderPip.setAttribute('y', y);\n  });\n\n  const sliderTrack = createSVG('rect', {\n    width: trackWidth,\n    height,\n    fill: `url(#${linearGradientPattern.id})`,\n    x: width + spaceBetween,\n  });\n\n  body.appendChild(sliderTrack);\n  body.appendChild(sliderPip);\n\n  mainColor.subscribe((COLOR, PREV) => {\n    lastValid = {\n      x: COLOR[colorSpace][xChannel],\n      y: COLOR[colorSpace][yChannel],\n      z: COLOR[colorSpace][zChannel],\n    };\n\n    const xVal = COLOR[colorSpace][xChannel] / xMax*(width - XY_SLIDER_PADDING * 2) + XY_SLIDER_PADDING;\n    const yVal = (1 - COLOR[colorSpace][yChannel] / yMax) * (height - XY_SLIDER_PADDING * 2) + XY_SLIDER_PADDING;\n\n    pip.setAttribute('cx', xVal);\n    pip.setAttribute('cy', yVal);\n    v.setAttribute('x1', xVal);\n    v.setAttribute('x2', xVal);\n    inputX.style.left = (xVal + outerMargin) / DIM_RATIO;\n    if (document.activeElement !== inputX) inputX.value = COLOR[colorSpace][xChannel].toFixed(1);\n\n    h.setAttribute('y1', yVal);\n    h.setAttribute('y2', yVal);\n    inputY.style.top = (yVal + outerMargin) / DIM_RATIO;\n    if (document.activeElement !== inputY) inputY.value = COLOR[colorSpace][yChannel].toFixed(1);\n\n    if (document.activeElement !== inputZ) inputZ.value = COLOR[colorSpace][zChannel].toFixed(1);\n  });\n\n  pip.addEventListener('mousedown', (e) => {\n    let x = e.clientX;\n    let y = e.clientY;\n    function move(e) {\n      const delX = (e.clientX - x) / (width - 2 * XY_SLIDER_PADDING) * DIM_RATIO * xMax;\n      const delY = (y - e.clientY) / (height - 2 * XY_SLIDER_PADDING) * DIM_RATIO * yMax;\n      const rawY = mainColor.color[colorSpace][yChannel] + delY;\n      const rawX = mainColor.color[colorSpace][xChannel] + delX;\n\n      let nY = Math.max(rawY, 0);\n      nY = Math.min(nY, yMax);\n\n      let nX = Math.max(rawX, 0);\n      nX = Math.min(nX, xMax);\n\n      mainColor.set(colorSpace, {\n        [xChannel]: nX,\n        [yChannel]: nY,\n      });\n\n      if (nY === rawY) y = e.clientY;\n      // note: the conditional here prevents deltas from being erroneously registered when we're outside of the slider box.\n      if (nX === rawX) x = e.clientX;\n    }\n    document.addEventListener('mousemove', move);\n    document.addEventListener('mouseup', () => {\n      document.removeEventListener('mousemove', move);\n    }, { once: true });\n  });\n\n  const container = document.createElement('div');\n  Object.assign(container.style, {\n    position: 'relative',\n  });\n\n  target.appendChild(container);\n  container.appendChild(svg);\n  container.appendChild(inputX);\n  container.appendChild(inputY);\n  container.appendChild(inputZ);\n  svg.appendChild(defs);\n  svg.appendChild(body);\n  body.appendChild(xySVG);\n  body.appendChild(v);\n  body.appendChild(h);\n  body.appendChild(pip);\n  defs.appendChild(linearGradientPattern);\n  defs.appendChild(xyGradientPattern);\n\n  function setRatio() {\n    DIM_RATIO = SVG_HEIGHT / svg.getBoundingClientRect().height;\n  }\n  setRatio();\n  window.addEventListener('resize', setRatio);\n\n  Object.assign(inputZ.style, {\n    position: 'absolute',\n    margin: 0,\n    right: (outerMargin + trackWidth / 2) / DIM_RATIO,\n    top: '10px',\n    transform: 'translateX(50%)translateY(-100%)',\n  });\n  inputZ.addEventListener('input', (e) => {\n    e.preventDefault();\n    if (isNaN(+inputZ.value) || +inputZ.value < 0 || +inputZ.value > zMax) return;\n    mainColor.set(\n      colorSpace,\n      { [zChannel]: +inputZ.value },\n    );\n  });\n  inputZ.addEventListener('blur', () => {\n    inputZ.value = lastValid.z.toFixed(1);\n  });\n\n  Object.assign(inputY.style, {\n    position: 'absolute',\n    margin: 0,\n    left: outerMargin / DIM_RATIO,\n    transform: 'translateY(-50%)translateX(-100%)',\n  });\n}\n","// Generated by Haxe 3.4.4\nvar hsluv = hsluv || {};\nhsluv.Geometry = function() { };\nhsluv.Geometry.intersectLineLine = function(a,b) {\n\tvar x = (a.intercept - b.intercept) / (b.slope - a.slope);\n\tvar y = a.slope * x + a.intercept;\n\treturn { x : x, y : y};\n};\nhsluv.Geometry.distanceFromOrigin = function(point) {\n\treturn Math.sqrt(Math.pow(point.x,2) + Math.pow(point.y,2));\n};\nhsluv.Geometry.distanceLineFromOrigin = function(line) {\n\treturn Math.abs(line.intercept) / Math.sqrt(Math.pow(line.slope,2) + 1);\n};\nhsluv.Geometry.perpendicularThroughPoint = function(line,point) {\n\tvar slope = -1 / line.slope;\n\tvar intercept = point.y - slope * point.x;\n\treturn { slope : slope, intercept : intercept};\n};\nhsluv.Geometry.angleFromOrigin = function(point) {\n\treturn Math.atan2(point.y,point.x);\n};\nhsluv.Geometry.normalizeAngle = function(angle) {\n\tvar m = 2 * Math.PI;\n\treturn (angle % m + m) % m;\n};\nhsluv.Geometry.lengthOfRayUntilIntersect = function(theta,line) {\n\treturn line.intercept / (Math.sin(theta) - line.slope * Math.cos(theta));\n};\nhsluv.Hsluv = function() { };\nhsluv.Hsluv.getBounds = function(L) {\n\tvar result = [];\n\tvar sub1 = Math.pow(L + 16,3) / 1560896;\n\tvar sub2 = sub1 > hsluv.Hsluv.epsilon ? sub1 : L / hsluv.Hsluv.kappa;\n\tvar _g = 0;\n\twhile(_g < 3) {\n\t\tvar c = _g++;\n\t\tvar m1 = hsluv.Hsluv.m[c][0];\n\t\tvar m2 = hsluv.Hsluv.m[c][1];\n\t\tvar m3 = hsluv.Hsluv.m[c][2];\n\t\tvar _g1 = 0;\n\t\twhile(_g1 < 2) {\n\t\t\tvar t = _g1++;\n\t\t\tvar top1 = (284517 * m1 - 94839 * m3) * sub2;\n\t\t\tvar top2 = (838422 * m3 + 769860 * m2 + 731718 * m1) * L * sub2 - 769860 * t * L;\n\t\t\tvar bottom = (632260 * m3 - 126452 * m2) * sub2 + 126452 * t;\n\t\t\tresult.push({ slope : top1 / bottom, intercept : top2 / bottom});\n\t\t}\n\t}\n\treturn result;\n};\nhsluv.Hsluv.maxSafeChromaForL = function(L) {\n\tvar bounds = hsluv.Hsluv.getBounds(L);\n\tvar min = Infinity;\n\tvar _g = 0;\n\twhile(_g < bounds.length) {\n\t\tvar bound = bounds[_g];\n\t\t++_g;\n\t\tvar length = hsluv.Geometry.distanceLineFromOrigin(bound);\n\t\tmin = Math.min(min,length);\n\t}\n\treturn min;\n};\nhsluv.Hsluv.maxChromaForLH = function(L,H) {\n\tvar hrad = H / 360 * Math.PI * 2;\n\tvar bounds = hsluv.Hsluv.getBounds(L);\n\tvar min = Infinity;\n\tvar _g = 0;\n\twhile(_g < bounds.length) {\n\t\tvar bound = bounds[_g];\n\t\t++_g;\n\t\tvar length = hsluv.Geometry.lengthOfRayUntilIntersect(hrad,bound);\n\t\tif(length >= 0) {\n\t\t\tmin = Math.min(min,length);\n\t\t}\n\t}\n\treturn min;\n};\nhsluv.Hsluv.dotProduct = function(a,b) {\n\tvar sum = 0;\n\tvar _g1 = 0;\n\tvar _g = a.length;\n\twhile(_g1 < _g) {\n\t\tvar i = _g1++;\n\t\tsum += a[i] * b[i];\n\t}\n\treturn sum;\n};\nhsluv.Hsluv.fromLinear = function(c) {\n\tif(c <= 0.0031308) {\n\t\treturn 12.92 * c;\n\t} else {\n\t\treturn 1.055 * Math.pow(c,0.416666666666666685) - 0.055;\n\t}\n};\nhsluv.Hsluv.toLinear = function(c) {\n\tif(c > 0.04045) {\n\t\treturn Math.pow((c + 0.055) / 1.055,2.4);\n\t} else {\n\t\treturn c / 12.92;\n\t}\n};\nhsluv.Hsluv.xyzToRgb = function(tuple) {\n\treturn [hsluv.Hsluv.fromLinear(hsluv.Hsluv.dotProduct(hsluv.Hsluv.m[0],tuple)),hsluv.Hsluv.fromLinear(hsluv.Hsluv.dotProduct(hsluv.Hsluv.m[1],tuple)),hsluv.Hsluv.fromLinear(hsluv.Hsluv.dotProduct(hsluv.Hsluv.m[2],tuple))];\n};\nhsluv.Hsluv.rgbToXyz = function(tuple) {\n\tvar rgbl = [hsluv.Hsluv.toLinear(tuple[0]),hsluv.Hsluv.toLinear(tuple[1]),hsluv.Hsluv.toLinear(tuple[2])];\n\treturn [hsluv.Hsluv.dotProduct(hsluv.Hsluv.minv[0],rgbl),hsluv.Hsluv.dotProduct(hsluv.Hsluv.minv[1],rgbl),hsluv.Hsluv.dotProduct(hsluv.Hsluv.minv[2],rgbl)];\n};\nhsluv.Hsluv.yToL = function(Y) {\n\tif(Y <= hsluv.Hsluv.epsilon) {\n\t\treturn Y / hsluv.Hsluv.refY * hsluv.Hsluv.kappa;\n\t} else {\n\t\treturn 116 * Math.pow(Y / hsluv.Hsluv.refY,0.333333333333333315) - 16;\n\t}\n};\nhsluv.Hsluv.lToY = function(L) {\n\tif(L <= 8) {\n\t\treturn hsluv.Hsluv.refY * L / hsluv.Hsluv.kappa;\n\t} else {\n\t\treturn hsluv.Hsluv.refY * Math.pow((L + 16) / 116,3);\n\t}\n};\nhsluv.Hsluv.xyzToLuv = function(tuple) {\n\tvar X = tuple[0];\n\tvar Y = tuple[1];\n\tvar Z = tuple[2];\n\tvar divider = X + 15 * Y + 3 * Z;\n\tvar varU = 4 * X;\n\tvar varV = 9 * Y;\n\tif(divider != 0) {\n\t\tvarU /= divider;\n\t\tvarV /= divider;\n\t} else {\n\t\tvarU = NaN;\n\t\tvarV = NaN;\n\t}\n\tvar L = hsluv.Hsluv.yToL(Y);\n\tif(L == 0) {\n\t\treturn [0,0,0];\n\t}\n\tvar U = 13 * L * (varU - hsluv.Hsluv.refU);\n\tvar V = 13 * L * (varV - hsluv.Hsluv.refV);\n\treturn [L,U,V];\n};\nhsluv.Hsluv.luvToXyz = function(tuple) {\n\tvar L = tuple[0];\n\tvar U = tuple[1];\n\tvar V = tuple[2];\n\tif(L == 0) {\n\t\treturn [0,0,0];\n\t}\n\tvar varU = U / (13 * L) + hsluv.Hsluv.refU;\n\tvar varV = V / (13 * L) + hsluv.Hsluv.refV;\n\tvar Y = hsluv.Hsluv.lToY(L);\n\tvar X = 0 - 9 * Y * varU / ((varU - 4) * varV - varU * varV);\n\tvar Z = (9 * Y - 15 * varV * Y - varV * X) / (3 * varV);\n\treturn [X,Y,Z];\n};\nhsluv.Hsluv.luvToLch = function(tuple) {\n\tvar L = tuple[0];\n\tvar U = tuple[1];\n\tvar V = tuple[2];\n\tvar C = Math.sqrt(U * U + V * V);\n\tvar H;\n\tif(C < 0.00000001) {\n\t\tH = 0;\n\t} else {\n\t\tvar Hrad = Math.atan2(V,U);\n\t\tH = Hrad * 180.0 / Math.PI;\n\t\tif(H < 0) {\n\t\t\tH = 360 + H;\n\t\t}\n\t}\n\treturn [L,C,H];\n};\nhsluv.Hsluv.lchToLuv = function(tuple) {\n\tvar L = tuple[0];\n\tvar C = tuple[1];\n\tvar H = tuple[2];\n\tvar Hrad = H / 360.0 * 2 * Math.PI;\n\tvar U = Math.cos(Hrad) * C;\n\tvar V = Math.sin(Hrad) * C;\n\treturn [L,U,V];\n};\nhsluv.Hsluv.hsluvToLch = function(tuple) {\n\tvar H = tuple[0];\n\tvar S = tuple[1];\n\tvar L = tuple[2];\n\tif(L > 99.9999999) {\n\t\treturn [100,0,H];\n\t}\n\tif(L < 0.00000001) {\n\t\treturn [0,0,H];\n\t}\n\tvar max = hsluv.Hsluv.maxChromaForLH(L,H);\n\tvar C = max / 100 * S;\n\treturn [L,C,H];\n};\nhsluv.Hsluv.lchToHsluv = function(tuple) {\n\tvar L = tuple[0];\n\tvar C = tuple[1];\n\tvar H = tuple[2];\n\tif(L > 99.9999999) {\n\t\treturn [H,0,100];\n\t}\n\tif(L < 0.00000001) {\n\t\treturn [H,0,0];\n\t}\n\tvar max = hsluv.Hsluv.maxChromaForLH(L,H);\n\tvar S = C / max * 100;\n\treturn [H,S,L];\n};\nhsluv.Hsluv.hpluvToLch = function(tuple) {\n\tvar H = tuple[0];\n\tvar S = tuple[1];\n\tvar L = tuple[2];\n\tif(L > 99.9999999) {\n\t\treturn [100,0,H];\n\t}\n\tif(L < 0.00000001) {\n\t\treturn [0,0,H];\n\t}\n\tvar max = hsluv.Hsluv.maxSafeChromaForL(L);\n\tvar C = max / 100 * S;\n\treturn [L,C,H];\n};\nhsluv.Hsluv.lchToHpluv = function(tuple) {\n\tvar L = tuple[0];\n\tvar C = tuple[1];\n\tvar H = tuple[2];\n\tif(L > 99.9999999) {\n\t\treturn [H,0,100];\n\t}\n\tif(L < 0.00000001) {\n\t\treturn [H,0,0];\n\t}\n\tvar max = hsluv.Hsluv.maxSafeChromaForL(L);\n\tvar S = C / max * 100;\n\treturn [H,S,L];\n};\nhsluv.Hsluv.rgbToHex = function(tuple) {\n\tvar h = \"#\";\n\tvar _g = 0;\n\twhile(_g < 3) {\n\t\tvar i = _g++;\n\t\tvar chan = tuple[i];\n\t\tvar c = Math.round(chan * 255);\n\t\tvar digit2 = c % 16;\n\t\tvar digit1 = (c - digit2) / 16 | 0;\n\t\th += hsluv.Hsluv.hexChars.charAt(digit1) + hsluv.Hsluv.hexChars.charAt(digit2);\n\t}\n\treturn h;\n};\nhsluv.Hsluv.hexToRgb = function(hex) {\n\thex = hex.toLowerCase();\n\tvar ret = [];\n\tvar _g = 0;\n\twhile(_g < 3) {\n\t\tvar i = _g++;\n\t\tvar digit1 = hsluv.Hsluv.hexChars.indexOf(hex.charAt(i * 2 + 1));\n\t\tvar digit2 = hsluv.Hsluv.hexChars.indexOf(hex.charAt(i * 2 + 2));\n\t\tvar n = digit1 * 16 + digit2;\n\t\tret.push(n / 255.0);\n\t}\n\treturn ret;\n};\nhsluv.Hsluv.lchToRgb = function(tuple) {\n\treturn hsluv.Hsluv.xyzToRgb(hsluv.Hsluv.luvToXyz(hsluv.Hsluv.lchToLuv(tuple)));\n};\nhsluv.Hsluv.rgbToLch = function(tuple) {\n\treturn hsluv.Hsluv.luvToLch(hsluv.Hsluv.xyzToLuv(hsluv.Hsluv.rgbToXyz(tuple)));\n};\nhsluv.Hsluv.hsluvToRgb = function(tuple) {\n\treturn hsluv.Hsluv.lchToRgb(hsluv.Hsluv.hsluvToLch(tuple));\n};\nhsluv.Hsluv.rgbToHsluv = function(tuple) {\n\treturn hsluv.Hsluv.lchToHsluv(hsluv.Hsluv.rgbToLch(tuple));\n};\nhsluv.Hsluv.hpluvToRgb = function(tuple) {\n\treturn hsluv.Hsluv.lchToRgb(hsluv.Hsluv.hpluvToLch(tuple));\n};\nhsluv.Hsluv.rgbToHpluv = function(tuple) {\n\treturn hsluv.Hsluv.lchToHpluv(hsluv.Hsluv.rgbToLch(tuple));\n};\nhsluv.Hsluv.hsluvToHex = function(tuple) {\n\treturn hsluv.Hsluv.rgbToHex(hsluv.Hsluv.hsluvToRgb(tuple));\n};\nhsluv.Hsluv.hpluvToHex = function(tuple) {\n\treturn hsluv.Hsluv.rgbToHex(hsluv.Hsluv.hpluvToRgb(tuple));\n};\nhsluv.Hsluv.hexToHsluv = function(s) {\n\treturn hsluv.Hsluv.rgbToHsluv(hsluv.Hsluv.hexToRgb(s));\n};\nhsluv.Hsluv.hexToHpluv = function(s) {\n\treturn hsluv.Hsluv.rgbToHpluv(hsluv.Hsluv.hexToRgb(s));\n};\nhsluv.Hsluv.m = [[3.240969941904521,-1.537383177570093,-0.498610760293],[-0.96924363628087,1.87596750150772,0.041555057407175],[0.055630079696993,-0.20397695888897,1.056971514242878]];\nhsluv.Hsluv.minv = [[0.41239079926595,0.35758433938387,0.18048078840183],[0.21263900587151,0.71516867876775,0.072192315360733],[0.019330818715591,0.11919477979462,0.95053215224966]];\nhsluv.Hsluv.refY = 1.0;\nhsluv.Hsluv.refU = 0.19783000664283;\nhsluv.Hsluv.refV = 0.46831999493879;\nhsluv.Hsluv.kappa = 903.2962962;\nhsluv.Hsluv.epsilon = 0.0088564516;\nhsluv.Hsluv.hexChars = \"0123456789abcdef\";\nvar root = {\n    \"hsluvToRgb\": hsluv.Hsluv.hsluvToRgb,\n    \"rgbToHsluv\": hsluv.Hsluv.rgbToHsluv,\n    \"hpluvToRgb\": hsluv.Hsluv.hpluvToRgb,\n    \"rgbToHpluv\": hsluv.Hsluv.rgbToHpluv,\n    \"hsluvToHex\": hsluv.Hsluv.hsluvToHex,\n    \"hexToHsluv\": hsluv.Hsluv.hexToHsluv,\n    \"hpluvToHex\": hsluv.Hsluv.hpluvToHex,\n    \"hexToHpluv\": hsluv.Hsluv.hexToHpluv,\n    \"lchToHpluv\": hsluv.Hsluv.lchToHpluv,\n    \"hpluvToLch\": hsluv.Hsluv.hpluvToLch,\n    \"lchToHsluv\": hsluv.Hsluv.lchToHsluv,\n    \"hsluvToLch\": hsluv.Hsluv.hsluvToLch,\n    \"lchToLuv\": hsluv.Hsluv.lchToLuv,\n    \"luvToLch\": hsluv.Hsluv.luvToLch,\n    \"xyzToLuv\": hsluv.Hsluv.xyzToLuv,\n    \"luvToXyz\": hsluv.Hsluv.luvToXyz,\n    \"xyzToRgb\": hsluv.Hsluv.xyzToRgb,\n    \"rgbToXyz\": hsluv.Hsluv.rgbToXyz,\n    \"lchToRgb\": hsluv.Hsluv.lchToRgb,\n    \"rgbToLch\": hsluv.Hsluv.rgbToLch\n};\n\nmodule.exports = root;\n"],"sourceRoot":""}